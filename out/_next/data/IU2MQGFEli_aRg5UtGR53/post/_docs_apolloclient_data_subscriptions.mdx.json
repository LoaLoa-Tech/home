{"pageProps":{"markdownPost":{"name":null,"url":null,"content":"---\ntitle: Subscriptions\ndescription: Get real-time updates from your GraphQL server\n---\n\nimport SubscriptionOptions from '../../shared/subscription-options.mdx';\nimport SubscriptionResult from '../../shared/subscription-result.mdx';\n\nIn addition to [queries](./queries/) and [mutations](./mutations/), GraphQL supports a third operation type: **subscriptions**.\n\nLike queries, subscriptions enable you to fetch data. _Unlike_ queries, subscriptions maintain an active connection to your GraphQL server (most commonly via WebSocket). This enables your server to push updates to the subscription's result over time.\n\nSubscriptions are useful for notifying your client in real time about changes to back-end data, such as the creation of a new object or updates to an important field.\n\n## When to use subscriptions\n\nIn the majority of cases, your client should _not_ use subscriptions to stay up to date with your backend. Instead, you should [poll intermittently](./queries/#polling) with queries, or [re-execute queries on demand](./queries/#refetching) when a user performs a relevant action.\n\nYou _should_ use subscriptions for the following:\n\n* **Small, incremental changes to large objects**. Repeatedly polling for a large object is expensive, especially when most of the object's fields rarely change. Instead, you can fetch the object's initial state with a query, and your server can proactively push updates to individual fields as they occur.\n\n* **Low-latency, real-time updates**. For example, a chat application's client wants to receive new messages as soon as they're available.\n\n## Defining a subscription\n\nYou define a subscription on both the server side and the client side, just like you do for queries and mutations.\n\n### Server side\n\nYou define available subscriptions in your [GraphQL schema](https://www.apollographql.com/docs/apollo-server/schema/schema/#supported-types) as fields of the `Subscription` type. The following `commentAdded` subscription notifies a subscribing client whenever a new comment is added to a particular blog post (specified by `postID`):\n\n```graphql\ntype Subscription {\n  commentAdded(postID: ID!): Comment\n}\n```\n\nFor more information on implementing support for subscriptions on the server side, see the [Apollo Server documentation for subscriptions](https://www.apollographql.com/docs/apollo-server/data/subscriptions/).\n\n### Client side\n\nIn your application's client, you define the shape of each subscription you want Apollo Client to execute, like so:\n\n```js\nconst COMMENTS_SUBSCRIPTION = gql`\n  subscription OnCommentAdded($repoFullName: String!) {\n    commentAdded(repoFullName: $repoFullName) {\n      id\n      content\n    }\n  }\n`;\n```\n\nWhen Apollo Client executes the `onCommentAdded` subscription, it establishes a connection to your GraphQL server and listens for response data. Unlike with a query, there is no expectation that the server will immediately process and return a response. Instead, your server only pushes data to your client when a particular event occurs on your backend.\n\nWhenever your GraphQL server _does_ push data to a subscribing client, that data conforms to the structure of the executed subscription, just like it does for a query:\n\n```json\n{\n  \"data\": {\n    \"commentAdded\": {\n      \"id\": \"123\",\n      \"content\": \"What a thoughtful and well written post!\"\n    }\n  }\n}\n```\n\n## Setting up the transport\n\nBecause subscriptions maintain a persistent connection, they can't use the default HTTP transport that Apollo Client uses for queries and mutations. Instead, Apollo Client subscriptions most commonly communicate over WebSocket, via the community-maintained [`subscriptions-transport-ws`](https://github.com/apollographql/subscriptions-transport-ws) library.\n\n### 1. Install required libraries\n\n**Apollo Link** is a collection of libraries that help you customize Apollo Client's network communication. One of these libraries is `@apollo/client/link/ws`, which enables communication over WebSocket.\n\nInstall both `@apollo/client/link/ws` and `subscriptions-transport-ws` in your project, like so:\n\n```bash\nnpm install @apollo/client subscriptions-transport-ws\n```\n\n### 2. Initialize a `WebSocketLink`\n\nImport and initialize a `WebSocketLink` object in the same project file where you initialize `ApolloClient`:\n\n```js\nimport { WebSocketLink } from '@apollo/client/link/ws';\n\nconst wsLink = new WebSocketLink({\n  uri: `ws://localhost:5000/`,\n  options: {\n    reconnect: true\n  }\n});\n```\n\nReplace the value of the `uri` option with the URL of your GraphQL server. This is often a `localhost` URL during development.\n\n### 3. Use different transports for different operations\n\nApollo Client should use your `WebSocketLink` for subscriptions, but it _shouldn't_ use it for queries or mutations. For those operations, Apollo Client should use HTTP as usual. To support this, the `@apollo/client` library provides a `split` function that lets you use one of two different `Link`s, according to the result of a boolean check.\n\nThe following example expands on the previous one by initializing both a `WebSocketLink` _and_ an `HttpLink`. It then uses the `split` function to combine those two `Link`s into a _single_ `Link` that uses one or the other according to the type of operation being executed.\n\n```js\nimport { split, HttpLink } from '@apollo/client';\nimport { getMainDefinition } from '@apollo/client/utilities';\nimport { WebSocketLink } from '@apollo/client/link/ws';\n\nconst httpLink = new HttpLink({\n  uri: 'http://localhost:3000/'\n});\n\nconst wsLink = new WebSocketLink({\n  uri: `ws://localhost:5000/`,\n  options: {\n    reconnect: true\n  }\n});\n\n// The split function takes three parameters:\n//\n// * A function that's called for each operation to execute\n// * The Link to use for an operation if the function returns a \"truthy\" value\n// * The Link to use for an operation if the function returns a \"falsy\" value\nconst splitLink = split(\n  ({ query }) => {\n    const definition = getMainDefinition(query);\n    return (\n      definition.kind === 'OperationDefinition' &&\n      definition.operation === 'subscription'\n    );\n  },\n  wsLink,\n  httpLink,\n);\n```\n\nUsing this logic, queries and mutations will use HTTP as normal, and subscriptions will use WebSocket.\n\n### 4. Authenticate over WebSocket (optional)\n\nIt is often necessary to authenticate a client before allowing it to receive subscription results. To do this, you can provide a `connectionParams` option to the `WebSocketLink` constructor, like so:\n\n```js{7-9}\nimport { WebSocketLink } from '@apollo/client/link/ws';\n\nconst wsLink = new WebSocketLink({\n  uri: `ws://localhost:5000/`,\n  options: {\n    reconnect: true,\n    connectionParams: {\n      authToken: user.authToken,\n    },\n  },\n});\n```\n\nYour `WebSocketLink` passes the `connectionParams` object to your server whenever it connects. If your server has a [SubscriptionsServer](https://www.apollographql.com/docs/graphql-subscriptions/authentication) object that's listening for WebSocket connections, it receives the `connectionParams` object and can use it to perform authentication, along with any other connection-related tasks.\n\n\n## Executing a subscription\n\nYou use Apollo Client's `useSubscription` Hook to execute a subscription from React. Like [`useQuery`](./queries/#executing-a-query), `useSubscription` returns an object from Apollo Client that contains `loading`, `error`, and `data` properties you can use to render your UI.\n\nThe following example component uses the subscription we defined earlier to render the most recent comment that's been added to a specified blog post. Whenever the GraphQL server pushes a new comment to the client, the component re-renders with the new comment.\n\n```jsx\nconst COMMENTS_SUBSCRIPTION = gql`\n  subscription OnCommentAdded($postID: ID!) {\n    commentAdded(postID: $postID) {\n      id\n      content\n    }\n  }\n`;\n\nfunction LatestComment({ postID }) {\n  const { data: { commentAdded }, loading } = useSubscription(\n    COMMENTS_SUBSCRIPTION,\n    { variables: { postID } }\n  );\n  return <h4>New comment: {!loading && commentAdded.content}</h4>;\n}\n```\n\n## Subscribing to updates for a query\n\nWhenever a query returns a result in Apollo Client, that result includes a `subscribeToMore` function. You can use this function to execute a followup subscription that pushes updates to the query's original result.\n\n> The `subscribeToMore` function is similar in structure to the [`fetchMore`](../caching/advanced-topics/#incremental-loading-fetchmore) function that's commonly used for handling pagination. The primary difference is that `fetchMore` executes a followup _query_, whereas `subscribeToMore` executes a subscription.\n\nAs an example, let's start with a standard query that fetches all of the existing comments for a given blog post:\n\n```jsx\nconst COMMENTS_QUERY = gql`\n  query CommentsForPost($postID: ID!) {\n    post(postID: $postID) {\n      comments {\n        id\n        content\n      }\n    }\n  }\n`;\n\nfunction CommentsPageWithData({ params }) {\n  const result = useQuery(\n    COMMENTS_QUERY,\n    { variables: { postID: params.postID } }\n  );\n  return <CommentsPage {...result} />;\n}\n```\n\nLet's say we want our GraphQL server to push an update to our client as soon as a _new_ comment is added to the post. First we need to define the subscription that Apollo Client will execute when the `COMMENTS_QUERY` returns:\n\n```jsx\nconst COMMENTS_SUBSCRIPTION = gql`\n  subscription OnCommentAdded($postID: ID!) {\n    commentAdded(postID: $postID) {\n      id\n      content\n    }\n  }\n`;\n```\n\nNext, we modify our `CommentsPageWithData` function to add a `subscribeToNewComments` property to the `CommentsPage` component it returns. This property is a function that will be responsible for calling `subscribeToMore` after the component mounts.\n\n```jsx{10-25}\nfunction CommentsPageWithData({ params }) {\n  const { subscribeToMore, ...result } = useQuery(\n    COMMENT_QUERY,\n    { variables: { postID: params.postID } }\n  );\n\n  return (\n    <CommentsPage\n      {...result}\n      subscribeToNewComments={() =>\n        subscribeToMore({\n          document: COMMENTS_SUBSCRIPTION,\n          variables: { postID: params.postID },\n          updateQuery: (prev, { subscriptionData }) => {\n            if (!subscriptionData.data) return prev;\n            const newFeedItem = subscriptionData.data.commentAdded;\n\n            return Object.assign({}, prev, {\n              post: {\n                comments: [newFeedItem, ...prev.post.comments]\n              }\n            });\n          }\n        })\n      }\n    />\n  );\n}\n```\n\nIn the example above, we pass three options to `subscribeToMore`:\n\n* `document` indicates the subscription to execute.\n* `variables` indicates the variables to include when executing the subscription.\n* `updateQuery` is a function that tells Apollo Client how to combine the query's currently cached result (`prev`) with the `subscriptionData` that's pushed by our GraphQL server. The return value of this function **completely replaces** the current cached result for the query.\n\nFinally, in our definition of `CommentsPage`, we tell the component to `subscribeToNewComments` when it mounts:\n\n```js\nexport class CommentsPage extends Component {\n  componentDidMount() {\n    this.props.subscribeToNewComments();\n  }\n}\n```\n\n## `useSubscription` API reference\n\n> **Note:** If you're using React Apollo's `Subscription` render prop component, the option/result details listed below are still valid (options are component props and results are passed into the render prop function). The only difference is that a `subscription` prop (which holds a GraphQL subscription document parsed into an AST by `gql`) is also required.\n\n### Options\n\nThe `useSubscription` Hook accepts the following options:\n\n<SubscriptionOptions />\n\n### Result\n\nAfter being called, the `useSubscription` Hook returns a result object with the following properties:\n\n<SubscriptionResult />\n"}},"__N_SSG":true}