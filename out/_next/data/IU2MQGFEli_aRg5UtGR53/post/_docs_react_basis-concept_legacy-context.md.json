{"pageProps":{"markdownPost":{"name":null,"url":null,"content":"---\nid: legacy-context\ntitle: Legacy Context\npermalink: docs/legacy-context.html\n---\n\n> Note:\n>\n> The legacy context API will be removed in a future major version.\n> Use the [new context API](/docs/context.html) introduced with version 16.3.\n> The legacy API will continue working for all 16.x releases.\n\n## How To Use Context {#how-to-use-context}\n\n> This section documents a legacy API. See the [new API](/docs/context.html).\n\nSuppose you have a structure like:\n\n```javascript\nclass Button extends React.Component {\n  render() {\n    return (\n      <button style={{background: this.props.color}}>\n        {this.props.children}\n      </button>\n    );\n  }\n}\n\nclass Message extends React.Component {\n  render() {\n    return (\n      <div>\n        {this.props.text} <Button color={this.props.color}>Delete</Button>\n      </div>\n    );\n  }\n}\n\nclass MessageList extends React.Component {\n  render() {\n    const color = \"purple\";\n    const children = this.props.messages.map((message) =>\n      <Message text={message.text} color={color} />\n    );\n    return <div>{children}</div>;\n  }\n}\n```\n\nIn this example, we manually thread through a `color` prop in order to style the `Button` and `Message` components appropriately. Using context, we can pass this through the tree automatically:\n\n```javascript{6,13-15,21,28-30,40-42}\nimport PropTypes from 'prop-types';\n\nclass Button extends React.Component {\n  render() {\n    return (\n      <button style={{background: this.context.color}}>\n        {this.props.children}\n      </button>\n    );\n  }\n}\n\nButton.contextTypes = {\n  color: PropTypes.string\n};\n\nclass Message extends React.Component {\n  render() {\n    return (\n      <div>\n        {this.props.text} <Button>Delete</Button>\n      </div>\n    );\n  }\n}\n\nclass MessageList extends React.Component {\n  getChildContext() {\n    return {color: \"purple\"};\n  }\n\n  render() {\n    const children = this.props.messages.map((message) =>\n      <Message text={message.text} />\n    );\n    return <div>{children}</div>;\n  }\n}\n\nMessageList.childContextTypes = {\n  color: PropTypes.string\n};\n```\n\nBy adding `childContextTypes` and `getChildContext` to `MessageList` (the context provider), React passes the information down automatically and any component in the subtree (in this case, `Button`) can access it by defining `contextTypes`.\n\nIf `contextTypes` is not defined, then `context` will be an empty object.\n\n> Note:\n>\n> `React.PropTypes` has moved into a different package since React v15.5. Please use [the `prop-types` library instead](https://www.npmjs.com/package/prop-types) to define `contextTypes`.\n>\n> We provide [a codemod script](/blog/2017/04/07/react-v15.5.0.html#migrating-from-react.proptypes) to automate the conversion.\n\n### Parent-Child Coupling {#parent-child-coupling}\n\n> This section documents a legacy API. See the [new API](/docs/context.html).\n\nContext can also let you build an API where parents and children communicate. For example, one library that works this way is [React Router V4](https://reacttraining.com/react-router):\n\n```javascript\nimport { BrowserRouter as Router, Route, Link } from 'react-router-dom';\n\nconst BasicExample = () => (\n  <Router>\n    <div>\n      <ul>\n        <li><Link to=\"/\">Home</Link></li>\n        <li><Link to=\"/about\">About</Link></li>\n        <li><Link to=\"/topics\">Topics</Link></li>\n      </ul>\n\n      <hr />\n\n      <Route exact path=\"/\" component={Home} />\n      <Route path=\"/about\" component={About} />\n      <Route path=\"/topics\" component={Topics} />\n    </div>\n  </Router>\n);\n```\n\nBy passing down some information from the `Router` component, each `Link` and `Route` can communicate back to the containing `Router`.\n\nBefore you build components with an API similar to this, consider if there are cleaner alternatives. For example, you can pass entire React components as props if you'd like to.\n\n### Referencing Context in Lifecycle Methods {#referencing-context-in-lifecycle-methods}\n\n> This section documents a legacy API. See the [new API](/docs/context.html).\n\nIf `contextTypes` is defined within a component, the following [lifecycle methods](/docs/react-component.html#the-component-lifecycle) will receive an additional parameter, the `context` object:\n\n- [`constructor(props, context)`](/docs/react-component.html#constructor)\n- [`componentWillReceiveProps(nextProps, nextContext)`](/docs/react-component.html#componentwillreceiveprops)\n- [`shouldComponentUpdate(nextProps, nextState, nextContext)`](/docs/react-component.html#shouldcomponentupdate)\n- [`componentWillUpdate(nextProps, nextState, nextContext)`](/docs/react-component.html#componentwillupdate)\n\n> Note:\n>\n> As of React 16, `componentDidUpdate` no longer receives `prevContext`.\n\n### Referencing Context in Function Components {#referencing-context-in-stateless-function-components}\n\n> This section documents a legacy API. See the [new API](/docs/context.html).\n\nFunction components are also able to reference `context` if `contextTypes` is defined as a property of the function. The following code shows a `Button` component written as a function component.\n\n```javascript\nimport PropTypes from 'prop-types';\n\nconst Button = ({children}, context) =>\n  <button style={{background: context.color}}>\n    {children}\n  </button>;\n\nButton.contextTypes = {color: PropTypes.string};\n```\n\n### Updating Context {#updating-context}\n\n> This section documents a legacy API. See the [new API](/docs/context.html).\n\nDon't do it.\n\nReact has an API to update context, but it is fundamentally broken and you should not use it.\n\nThe `getChildContext` function will be called when the state or props changes. In order to update data in the context, trigger a local state update with `this.setState`. This will trigger a new context and changes will be received by the children.\n\n```javascript\nimport PropTypes from 'prop-types';\n\nclass MediaQuery extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {type:'desktop'};\n  }\n\n  getChildContext() {\n    return {type: this.state.type};\n  }\n\n  componentDidMount() {\n    const checkMediaQuery = () => {\n      const type = window.matchMedia(\"(min-width: 1025px)\").matches ? 'desktop' : 'mobile';\n      if (type !== this.state.type) {\n        this.setState({type});\n      }\n    };\n\n    window.addEventListener('resize', checkMediaQuery);\n    checkMediaQuery();\n  }\n\n  render() {\n    return this.props.children;\n  }\n}\n\nMediaQuery.childContextTypes = {\n  type: PropTypes.string\n};\n```\n\nThe problem is, if a context value provided by component changes, descendants that use that value won't update if an intermediate parent returns `false` from `shouldComponentUpdate`. This is totally out of control of the components using context, so there's basically no way to reliably update the context. [This blog post](https://medium.com/@mweststrate/how-to-safely-use-react-context-b7e343eff076) has a good explanation of why this is a problem and how you might get around it.\n"}},"__N_SSG":true}