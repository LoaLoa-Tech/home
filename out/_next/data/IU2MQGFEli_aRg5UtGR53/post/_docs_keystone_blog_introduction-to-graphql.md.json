{"pageProps":{"markdownPost":{"name":null,"url":null,"content":"<!--[meta]\nsection: blog\ntitle: Introduction to GraphQL\ndate: 2020-09-01\nauthor: Mike Riethmuller\norder: 2\n[meta]-->\n\nIn this tutorial we're going to discuss some of the key differences between REST and GraphQL APIs then create a GraphQL server with Node.js. You will need to know basic HTML and JavaScript, how to run a few commands in a terminal, as well as have Node and NPM installed.\n\n## What is an API?\n\nBroadly speaking an API can be defined as a way for programmers to interface with an application. This often means an API describes the functions and methods available to developers within a specific development environment. If that development environment is the public web, an API will usually refer to URL \"end-points\" used for sending and receiving data.\n\n## Rest APIs\n\nThe traditional method for interfacing with applications on the web is a REST API. One defining characteristic of REST APIs is they use [HTTP request methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods), such as `GET`, `PUT`, `POST` &`DELETE` to \"CRUD\" operations. Typically, `PUT` for Create, `GET` for Read, `POST` for Update and `DELETE` for Delete.\n\nThis structure makes REST predictable but also highlights some limitations. Since a request method is limited to a single `CRUD` operation, it encourages API design that has a single end-point for each entity in the system. For example, a simple website might have the following end-points:\n\n- <http://my-api.com/user>\n- <http://my-api.com/post>\n- <http://my-api.com/comment>\n- <http://my-api.com/page>\n\nIn large systems, this can lead to APIs with many dozen or even hundreds of end-points. This is a common criticism of REST.\n\nAnother criticism of REST is that a lot of APIs return a specific predefined shape. This means when you successfully \"hit\" an end-point, the data returned is determined by that end-point, not the request. This results in either fetching more data than you want, or perhaps more often, considerably less data than is required. Either outcome is not efficient.\n\nThese are some of the problems that GraphQL aims to solve.\n\n## GraphQL APIs\n\nGraphQL APIs usually have a single endpoint and allow the client to specify a `query` that returns only required data.\n\nA GraphQL query looks something like a this:\n\n```js\nquery getPage($id: Int!) {\n  Page(id: $id) {\n    author {\n      name\n    }\n  }\n}\n```\n\nThis query is fetching the `name` of a `User`, that is attached to the `author` field of a `Page`.\n\nFor GraphQL to validate and execute this query, it must know what fields available for a `Page`, that the `author` field is a reference to a `User`, what fields are available for a `User` and finally how to resolve the data.\n\nIt achieves this through `schema` definitions and resolvers. Schemas and types are an essential part of a GraphQL API. To create a GraphQL API, you need a server with a complete set of `types` that describe every possible input and return value for the API. You also need resolver functions that return values that match the `schema` definition.\n\n## Creating a GraphQL server\n\nLet's create a GraphQL server that will handle queries and mutations for `Posts` and `Users`.\n\nStart by creating a directory for the project with the following commands:\n\n```\nmkdir graphql-server-tutorial\ncd graphql-server-tutorial\nnpm init --yes\n```\n\nWe're going to use `apollo-server` to generate our API service and `http-server` to serve a static front-end. Run the following command to install these packages:\n\n```\nnpm install apollo-server http-server\n```\n\n### Defining a GraphQL schema\n\nThe first thing we need to do is define the schema for our API. Start by creating an `index.js` file in the root of the project directory. At the top of the file add the following:\n\n```js\nconst { ApolloServer, gql } = require('apollo-server');\n\nconst schema = gql`\n  type User {\n    id: ID!\n    name: String\n  }\n\n  type Page {\n    id: ID!\n    title: String\n    author: User\n    content: String\n  }\n\n  type Query {\n    Page(id: ID!): Page\n    User(id: ID!): User\n  }\n`;\n```\n\nBoth `String` and `ID` are built-in types GraphQL understands. We've created additional types for `User` and `Page`. You can probably see how types can be made up of nested types. This is how GraphQL queries can request deeply nested, related data in a way that REST APIs typically can't.\n\n**Note:** We're creating a really simple schema here with just a `User` and a `Page`. It's useful to understand how this works but in a larger system, you might not want to define every part of the GraphQL schema by hand. Keystone generates a GraphQL schema and resolvers for you while allowing you to manually extend the generated graphQL schema.\n\n### Defining resolvers\n\nResolvers fetch and return data for queries. The returned data must match the shape we defined in the schema.\n\nThe first thing we need is a data source. For the sake of this tutorial we're going to work with a fixed set of data. Add the following to `index.js`:\n\n```js\nconst users = [\n  {\n    id: '1',\n    name: 'Mike',\n  },\n];\n\nconst pages = [\n  {\n    id: '1',\n    name: 'Hello World',\n    author: users[0],\n    content: 'Lorem ipsum...',\n  },\n];\n```\n\nNow let's write some resolvers that return this data:\n\n```js\nconst resolvers = {\n  Query: {\n    Page: (_, args) => {\n      return pages.find(page => page.id === args.id);\n    },\n    User: (_, args) => {\n      return users.find(user => user.id === args.id);\n    },\n  },\n};\n```\n\nUnderstanding `types` and `resolvers` can be one of the biggest stumbling blocks when getting started with GraphQL. This can be particularly difficult if you are not already familiar with typed languages however the GraphQL schema syntax can be a good introduction to these concepts.\n\n### Starting Apollo\n\nTo start the server all we need to do is pass `ApolloServer` our complete schema and resolvers. Add the following to the bottom of `index.js`:\n\n```js\nconst server = new ApolloServer({ typeDefs: schema, resolvers });\n\nserver.listen().then(({ url }) => {\n  console.log(`ðŸš€ GraphQL server started at: ${url}`);\n});\n```\n\nOpen the generated `package.json` file and add a `start:server` command in the `scripts` section:\n\n```json\n\"scripts\": {\n  \"start:server\": \"node index.js\"\n}\n```\n\nThen run:\n\n```\nnpm run start:server\n```\n\nCongratulations! You should have a GraphQL server up and running.\n\n### Executing a GraphQL query\n\nThe query we wrote earlier should now work. Before we learn how to execute GraphQL queries in our own application let's test it out using the GraphQL Playground Apollo provides. Visit `http://localhost:4000` and paste the following query:\n\n```js\nquery getPage($id: ID!) {\n  Page(id: $id) {\n    author {\n      name\n    }\n  }\n}\n```\n\nWe still need to provide the `id`, so select \"QUERY VARIABLES\" in the bottom right and add the following JSON:\n\n```\n{\n  \"id\":\"1\"\n}\n```\n\nNow run the query and you should get the following result:\n\n```\n{\n  author: {\n    name: \"Mike\"\n  }\n}\n```\n\n<video style=\"max-width:100%;\" autoplay>\n  <source src=\"/gql-demo.mp4\"  type=\"video/mp4\"/>\n</video>\n\nTo send this query in a client application we need to use a `POST` request. The POST request should be sent to our GraphQL server with a content type of `application/json` and a JSON-encoded body similar to:\n\n```js\n{\n  \"query\": \"...\",\n  \"variables\": { \"id\": \"1\" }\n}\n```\n\nThere are many client libraries that can make sending and receiving GraphQL queries easier, however, you don't need a client library to send a simple GraphQL request. We can send a GraphQL request using the browsers [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).\n\nCreate a file called `index.html`. In that file place the following:\n\n```html\n<html>\n  <body>\n    <pre id=\"result\"></pre>\n    <script>\n      // write code here\n    </script>\n  </body>\n</html>\n```\n\nWe'll write code directly in script tag inside this HTML file - just to demonstrate the concept.\n\nAdd the following script to the page:\n\n```js\nfetch('http://localhost:4000', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({\n    query: 'query getPage($id: ID!) { Page(id: $id) { author { name } } }',\n    variables: '{ \"id\": \"1\"}',\n  }),\n})\n  .then(res => res.json())\n  .then(res => {\n    // render the data on the page and console\n    console.log(res.data);\n    document.querySelector('#result').innerHTML = JSON.stringify(res.data, null, 2);\n  });\n```\n\nLet's add a start command for the client to our `package.json`:\n\n```json\n\"scripts\": {\n  \"start:server\": \"node index.js\",\n  \"start:client\": \"npx http-server .\"\n}\n```\n\nWith the server running, open new terminal window and run:\n\n```\nnpm run start:client\n```\n\nVisit `http://localhost:8080` in your browser and you should see the result of the query rendered to the console and on the page.\n\nThis is just one of the ways you can fetch data in a client application. Tools like `graphql-tag` or `apollo-fetch` make formatting variables and sending requests easier. For larger applications something like `apollo-client` might be useful.\n\nWe hope this introduction has demystified some aspect of GraphQL for you or given you a better understanding of how Keystone generates its GraphQL server.\n"}},"__N_SSG":true}