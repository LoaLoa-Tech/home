{"pageProps":{"markdownPost":{"name":null,"url":null,"content":"---\ntitle: Fragments\ndescription: Learn how to use fragments to share fields across queries\n---\n\nA [GraphQL fragment](http://graphql.org/learn/queries/#fragments) is a piece of logic that a client can share between multiple queries and mutations.\n\nHere, we declare a `NameParts` fragment that can be used with any `Person` object:\n\n```graphql\nfragment NameParts on Person {\n  firstName\n  lastName\n}\n```\n\nA fragment includes a subset of the fields that are declared for its associated type. In the above example, the `Person` type must declare `firstName` and `lastName` fields for the `NameParts` fragment to be valid.\n\nWe can now include the `NameParts` fragment in any number of queries and mutations that refer to `Person` objects, like so:\n\n```graphql\nquery GetPerson {\n  people(id: \"7\") {\n    ...NameParts\n    avatar(size: LARGE)\n  }\n}\n```\n\nBased on our `NameParts` definition, the above query is equivalent to:\n\n```graphql\nquery GetPerson {\n  people(id: \"7\") {\n    firstName\n    lastName\n    avatar(size: LARGE)\n  }\n}\n```\n\nHowever, if we later change which fields are included in the `NameParts` fragment, we automatically change which fields are included in every operation that _uses_ the `NameParts` fragment. This reduces the effort required to keep fields consistent across a set of operations.\n\n## Reusing fragments\n\nFragments are useful for including an identical set of fields across multiple GraphQL operations. For example, a blog might define several operations related to comments, and each of those operations might need to include the same baseline set of fields from a `Comment` type.\n\nTo specify this baseline set of fields, we define a fragment that lists the `Comment` fields that every comment-related operation should include:\n\n```js\nimport { gql } from '@apollo/client';\n\nCommentsPage.fragments = {\n  comment: gql`\n    fragment CommentsPageComment on Comment {\n      id\n      postedBy {\n        login\n        html_url\n      }\n      createdAt\n      content\n    }\n  `,\n};\n```\n\nWe assign the fragment to `CommentsPage.fragments.comment` as a convention.\n\nTo embed a fragment inside a GraphQL operation, prefix its name with three periods (`...`), like so:\n\n```js\nconst SUBMIT_COMMENT_MUTATION = gql`\n  mutation SubmitComment($postFullName: String!, $commentContent: String!) {\n    submitComment(postFullName: $postFullName, commentContent: $commentContent) {\n      ...CommentsPageComment // highlight-line\n    }\n  }\n  ${CommentsPage.fragments.comment}\n`;\n\nexport const COMMENT_QUERY = gql`\n  query Comment($postName: String!) {\n    entry(postFullName: $postName) {\n      comments {\n        ...CommentsPageComment // highlight-line\n      }\n    }\n  }\n  ${CommentsPage.fragments.comment}\n`;\n```\n\n## Colocating fragments\n\nThe tree-like structure of a GraphQL response resembles the hierarchy of a frontend's rendered components. Because of this similarity, you can use fragments to split query logic up _between_ components, so that each component requests exactly the fields that it uses. This helps you make your component logic more succinct.\n\nConsider the following view hierarchy for an app:\n\n```\nFeedPage\n└── Feed\n    └── FeedEntry\n        ├── EntryInfo\n        └── VoteButtons\n```\n\nIn this app, the `FeedPage` component executes a query to fetch a list of `FeedEntry` objects. The `EntryInfo` and `VoteButtons` subcomponents need specific fields from the enclosing `FeedEntry` object.\n\n### Creating colocated fragments\n\nA colocated fragment is just like any other fragment, except it is attached to a particular component that uses the fragment's fields. For example, the `VoteButtons` child component of `FeedPage` might use the fields `score` and `vote { choice }` from the `FeedEntry` object:\n\n```js\nVoteButtons.fragments = {\n  entry: gql`\n    fragment VoteButtonsFragment on FeedEntry {\n      score\n      vote {\n        choice\n      }\n    }\n  `,\n};\n```\n\nAfter you define a fragment in a child component, the parent component can refer to child component fragments in its own fragment definitions, like so:\n\n```js\nFeedEntry.fragments = {\n  entry: gql`\n    fragment FeedEntryFragment on FeedEntry {\n      commentCount\n      repository {\n        full_name\n        html_url\n        owner {\n          avatar_url\n        }\n      }\n      ...VoteButtonsFragment\n      ...RepoInfoFragment\n    }\n    ${VoteButtons.fragments.entry}\n    ${RepoInfo.fragments.entry}\n  `,\n};\n```\n\nThere's nothing special about the naming of `VoteButtons.fragments.entry` or `RepoInfo.fragments.entry`. Any naming convention will work as long as you can easily and consistently retrieve a component's fragments given the component.\n\n### Importing fragments when using Webpack\n\nWhen loading `.graphql` files with [graphql-tag/loader](https://github.com/apollographql/graphql-tag/blob/main/loader.js), we can include fragments using `import` statements. For example:\n\n```graphql\n#import \"./someFragment.graphql\"\n```\n\nThis makes the contents of `someFragment.graphql` available to the current file. See the [Webpack Fragments](../integrations/webpack/#fragments) section for additional details.\n\n## Using fragments with unions and interfaces\n\nYou can define fragments on [unions and interfaces](https://www.apollographql.com/docs/apollo-server/schema/unions-interfaces/).\n\nHere's an example of a query that includes three in-line fragments:\n\n```graphql\nquery AllCharacters {\n  all_characters {\n\n    ... on Character {\n      name\n    }\n\n    ... on Jedi {\n      side\n    }\n\n    ... on Droid {\n      model\n    }\n  }\n}\n```\n\nThe `all_characters` query above returns a list of `Character` objects. The `Character` type is an interface that both the `Jedi` and `Droid` types implement. Each item in the list includes a `side` field if it's an object of type `Jedi`, and it includes a `model` field if it's of type `Droid`.\n\n**However**, for this query to work, your client needs to understand the polymorphic relationship between the `Character` interface and the types that implement it. To inform the client about these relationships, you can pass a `possibleTypes` option when creating the `InMemoryCache`.\n\n### Defining `possibleTypes` manually\n\n> The `possibleTypes` option is available in Apollo Client 3.0 and later.\n\nYou can pass a `possibleTypes` option to the `InMemoryCache` constructor to specify supertype-subtype relationships in your schema. This object maps the name of an interface or union type (the supertype) to the types that implement or belong to it (the subtypes).\n\nHere's an example `possibleTypes` declaration:\n\n```ts\nconst cache = new InMemoryCache({\n  possibleTypes: {\n    Character: [\"Jedi\", \"Droid\"],\n    Test: [\"PassingTest\", \"FailingTest\", \"SkippedTest\"],\n    Snake: [\"Viper\", \"Python\"],\n  },\n});\n```\n\nThis example lists three interfaces (`Character`, `Test`, and `Snake`) and the object types that implement them.\n\nIf your schema includes only a few unions and interfaces, you can probably specify your `possibleTypes` manually without issue. However, as your schema grows in size and complexity, you should consider [generating `possibleTypes` automatically from your schema](#generating-possibletypes-automatically).\n\n### Generating `possibleTypes` automatically\n\nThe following example script translates a GraphQL introspection query into a `possibleTypes` configuration object:\n\n```js\nconst fetch = require('cross-fetch');\nconst fs = require('fs');\n\nfetch(`${YOUR_API_HOST}/graphql`, {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({\n    variables: {},\n    query: `\n      {\n        __schema {\n          types {\n            kind\n            name\n            possibleTypes {\n              name\n            }\n          }\n        }\n      }\n    `,\n  }),\n}).then(result => result.json())\n  .then(result => {\n    const possibleTypes = {};\n\n    result.data.__schema.types.forEach(supertype => {\n      if (supertype.possibleTypes) {\n        possibleTypes[supertype.name] =\n          supertype.possibleTypes.map(subtype => subtype.name);\n      }\n    });\n\n    fs.writeFile('./possibleTypes.json', JSON.stringify(possibleTypes), err => {\n      if (err) {\n        console.error('Error writing possibleTypes.json', err);\n      } else {\n        console.log('Fragment types successfully extracted!');\n      }\n    });\n  });\n```\n\nYou can then `import` the generated `possibleTypes` JSON module into the file where you create your `InMemoryCache`:\n\n```ts\nimport possibleTypes from './path/to/possibleTypes.json';\n\nconst cache = new InMemoryCache({\n  possibleTypes,\n});\n```\n"}},"__N_SSG":true}