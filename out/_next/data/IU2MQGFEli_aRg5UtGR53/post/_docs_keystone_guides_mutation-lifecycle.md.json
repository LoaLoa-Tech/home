{"pageProps":{"markdownPost":{"name":null,"url":null,"content":"<!--[meta]\nsection: guides\ntitle: Mutation lifecycle\nsubSection: graphql\norder: 2\n[meta]-->\n\n# Mutation lifecycle\n\n## Table of Contents\n\n- [Introduction](#introduction)\n\n- [Mutation phases](#mutation-phases)\n\n  - [Access control phase](#access-control-phase)\n\n    - [1. Check List Access (create/update/delete/authenticate)](#1-check-list-access-createupdatedeleteauthenticate)\n    - [2. Get Item(s) (update/delete)](#2-get-items-updatedelete)\n    - [3. Check Field Access (create/update)](#3-check-field-access-createupdate)\n\n  - [Operational Phase](#operational-phase)\n\n    - [1. Resolve Defaults (create)](#1-resolve-defaults-create)\n    - [2. Resolve Relationship (create/update)](#2-resolve-relationship-createupdate)\n    - [3. Resolve Input (create/update/authenticate)](#3-resolve-input-createupdateauthenticate)\n    - [4. Validate Data (create/update/delete/authenticate)](#4-validate-data-createupdatedeleteauthenticate)\n    - [5. Before Operation (create/update/delete/authenticate)](#5-before-operation-createupdatedeleteauthenticate)\n    - [6. Database Operation (create/update/delete/authenticate)](#6-database-operation-createupdatedeleteauthenticate)\n    - [8. After Operation (create/update/delete/authenticate)](#8-after-operation-createupdatedeleteauthenticate)\n\n- [Summary](#summary)\n\n## Introduction\n\nThe KeystoneJS GraphQL API implements a CRUD API with `create`, `update` and `delete` mutations for each `List`.\nEach of these mutations can be applied to either a single item or many items at once.\n\nFor a `List` called `User` the GraphQL mutations would be:\n\n- Single item\n  - `createUser`\n  - `updateUser`\n  - `deleteUser`\n- Multiple items\n  - `createUsers`\n  - `updateUsers`\n  - `deleteUsers`\n\nEach of these mutations is implemented within Keystone by a corresponding resolver, implemented as a method on the core `List` object.\n\n| **GraphQL mutation** |     | **List resolver method** |\n| -------------------- | --- | ------------------------ |\n| `createUser`         | →   | `createMutation`         |\n| `updateUser`         | →   | `updateMutation`         |\n| `deleteUser`         | →   | `deleteMutation`         |\n| `createUsers`        | →   | `createManyMutation`     |\n| `updateUsers`        | →   | `updateManyMutation`     |\n| `deleteUsers`        | →   | `deleteManyMutation`     |\n\nKeystone provides [access control](/docs/guides/access-control.md) mechanisms and a [hook system](/docs/guides/hooks.md) which allows the developer to customise the behaviour of each of these mutations.\n\nThis document details the lifecycle of each mutation, and how the different access control mechanisms and hooks interact.\n\n## Mutation phases\n\nEach mutation goes through two key phases: the _Access Control Phase_ and the _Operational Phase_.\nDuring the Access Control Phase the developer defined access controls are evaluated, and the target items are retrieved from the database (`update` and `delete` only).\n\nDuring the Operational Phase the developer defined hooks are invoked, the mutation operation (create/update/delete) is performed in the database, and any nested mutations are performed.\n\nA new `execution transaction` is created at the beginning of the Operational Phase.\n\nThis transaction encapsulates a database transaction, as well as any state required to roll back the mutation operation in the event of an exception.\n\nThis transaction is used by all the nested mutations of the operation.\n\nThe Operational Phase for a `many` mutation consists of the the Operational Phase for the corresponding `single` mutation performed in parallel over each of the target items.\n\nEach of these `single` mutations is executed within its own transaction.\n\nAs such, a `many` mutation maybe have partial success during this phase, as some of the single mutations may succeed while others fail.\n\n### Access control phase\n\nDuring the Access Control Phase the target items are retrieved from the database, and access control is checked to ensure that the user has permission to perform the operation.\n\nThis phase will throw an `AccessDeniedError` if any of the access control checks fail. This error is returned in the `.errors` field of the GraphQL response. The Access Control Phase consists of three distinct steps.\n\n#### 1. Check List Access (`create/update/delete/authenticate`)\n\nThe first step in all mutations is to check that the user has access to perform the required operation on the `List`.\n\nIf access control has been defined statically or imperatively this check can be performed here. An `AccessDeniedError` is returned if the access control failed. If the access control mechanism for this list is defined declaratively (i.e using a GraphQL `where` statement), this check is deferred until the next step.\n\nFor more information on how to define access control, please consult the [access control documentation](/docs/guides/access-control.md).\n\n#### 2. Get Item(s) (`update/delete`)\n\nIn this step the targeted items are retrieved from the database.\n\nIf declarative access control is defined for this list, it is applied at this stage.\n\nIf the mutation is a single item mutation, an `AccessDeniedError` is returned if access is denied or if the requested item does not exist.\n\nIf the mutation is a multi item mutation then only those items which exist and pass access control are returned.\n\nNo error is thrown if some items do not exist or do not pass access control.\n\n#### 3. Check Field Access (`create/update`)\n\nThe field access permissions can now be checked.\n\nOnly those fields which are being set/updated have their permissions checked.\n\nAll relevant fields for all targeted items are checked in parallel and if any of them fail an `AccessDeniedError` is returned, listing all the fields which violated access control.\n\n### Operational Phase\n\nDuring the Operational Phase for a `single` mutation, the following steps are performed.\n\nThe Operational Phase for a `many` mutation will perform the Operational Phase for the corresponding `single` mutation across each item in parallel.\n\nThe Operational Phase consists of the following distinct steps.\n\n#### 1. Resolve Defaults (`create`)\n\nThe first step when creating a new item is to resolve any default values.\n\nAny fields which are not set on the provided item _and_ have a configured default value will be set to the default value.\n\nThe default value of a field can be configured at `List` definition time with the config attribute `defaultValue`.\n\nThe `defaultValue` may be a static value, or a function which returns either the value or a Promise.\n\nCustom field types can override this behaviour by defining the method `getDefaultValue()`.\n\nRelationship fields do not currently support default values.\n\n#### 2. Resolve Relationship (`create/update`)\n\nThe create and update mutations specify the value of relationship fields using the [nested mutation] pattern.\n\nThe nested mutations need to be resolved down to specific item IDs which will be inserted into the database.\n\nThis step performs the necessary database queries to identify the appropriate item IDs.\n\nIn the case that a nested mutation specifies a `create` operation, this will trigger a full `createMutation` on the related `List`.\n\nAny errors thrown by this nested `createMutation` will cause the current mutation to terminate, and the errors will be passed up the call stack.\n\nAs well as resolving the IDs and performing any nested create mutations, this step must also track.\n\n#### 3. Resolve Input (`create/update/authenticate`)\n\nThe `resolveInput` and `resolveAuthInput` hooks allows the developer to modify the incoming item before it is inserted/updated within the database.\n\nFor full details of how and when to use this hook, please consult the [API docs](/docs/api/hooks.md).\n\n#### 4. Validate Data (`create/update/delete/authenticate`)\n\nThe `validateInput`, `validateDelete` and `validateAuthInput` hooks allow the developer to specify validation rules which must be met before the data is inserted into the database.\n\nThese hooks can throw a `ValidationFailureError` when they encounter invalid data, which will terminate the operational phase.\n\nFor full details of how and when to use these hooks, please consult the [API docs](/docs/api/hooks.md).\n\n#### 5. Before Operation (`create/update/delete/authenticate`)\n\nThe `beforeChange`, `beforeDelete` and `beforeAuth` hooks allows the developer to perform any operations which interact with external systems, such as external data stores, which depend on resolved and validated data.\n\nFor full details of how and when to use these hooks, please consult the [API docs](/docs/api/hooks.md).\n\n#### 6. Database Operation (`create/update/delete/authenticate`)\n\nThe database operation is where the keystone database adapter is used to make the requested changes in the database.\nIn the case of `authenticate` operations no data is modified; the auth strategy `verify` function in invoked instead.\n\n#### 8. After Operation (`create/update/delete/authenticate`)\n\nThe `afterChange`, `afterDelete` and `afterAuth` hooks are only executed once all database operations for the mutation have been completed and the transaction has been finalised.\nThis means that the database is in a consistent state when this hook is executed.\nIt also means that if there is a failure of any kind during this hook, the operation will still be considered complete, and no roll back will be performed.\n\nFor full details of how and when to use these hooks, please consult the [API docs](/docs/api/hooks.md).\n\n## Summary\n\n![Mutation lifecycle master diagram](./MutationLifecycleMasterDiagram.svg)\n"}},"__N_SSG":true}