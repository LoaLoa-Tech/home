{"pageProps":{"markdownPost":{"name":null,"url":null,"content":"<!--[meta]\nsection: api\ntitle: Access control\norder: 4\n[meta]-->\n\n# Access control\n\nControl who can do what with your GraphQL API.\n\n> **Note:** This is the API documentation for access control. For getting started, see the [Access control guide](/docs/guides/access-control.md) or the [Authentication Guide](/docs/guides/authentication.md).\n\nThere are three domains of access control:\n\n1. List level\n2. Field level\n3. Custom schema\n\nTo set defaults for all lists, fields, and custom schema, use the `defaultAccess` config when\ncreating a `Keystone` instance. Each defaults to `true` if omitted.\n\n```javascript\nconst keystone = new Keystone('My App', {\n  defaultAccess: {\n    list: true,\n    field: true,\n    custom: true,\n  },\n});\n```\n\n## The `auth` operation\n\nIn addition to the standard Create/Read/Update/Delete (CRUD) operations, Keystone includes an Authenticate (`auth`) operation.\nAccess to this operation may be configured at list level (not field level) and controls whether authentication queries and mutations are accessible on that list.\n\nIf you have a `List` which is being used as the target of an Authentication Strategy, you should set `access: { auth: true }` on that list.\n\n## List level access control\n\nList level access control can have varying degrees of specificity depending on\nhow much control you need.\n\nA key on the list config, `access` can be specified either as a single control,\ncovering all CRUDA operations, or as an object keyed by CRUDA operation names.\n\nThere are 3 ways to define the values of `access`, in order of flexibility:\n\n1. Static\n2. Imperative\n3. Declarative\n\n```typescript\ninterface GraphQLWhere {\n  [key: string]: any;\n}\n\ninterface AccessInput {\n  authentication: {\n    item?: {};\n    listKey?: string;\n  };\n  listKey?: string;\n  operation?: string;\n  originalInput?: {};\n  gqlName?: string;\n  itemId?: string;\n  itemIds?: [string];\n}\n\ntype StaticAccess = boolean;\ntype ImperativeAccess = (arg: AccessInput) => boolean;\ntype DeclarativeAccess = GraphQLWhere | ((arg: AccessInput) => GraphQLWhere);\n\ninterface GranularAccess {\n  create?: StaticAccess | ImperativeAccess;\n  read?: StaticAccess | ImperativeAccess | DeclarativeAccess;\n  update?: StaticAccess | ImperativeAccess | DeclarativeAccess;\n  delete?: StaticAccess | ImperativeAccess | DeclarativeAccess;\n  auth?: StaticAccess;\n}\n\ntype ListConfig = {\n  access: StaticAccess | ImperativeAccess | GranularAccess;\n};\n```\n\n`GraphQLWhere` matches the `where` clause on the GraphQl type. For instance, on\nthe list `User` it would match the input type `UserWhereInput`.\n\n`AccessInput` has the following properties:\n\n| Property                 | Description                                                                                   |\n| ------------------------ | --------------------------------------------------------------------------------------------- |\n| `authentication`         | The currently authenticated user.                                                             |\n| `authentication.item`    | The details of the current user. Will be `undefined` for anonymous users.                     |\n| `authentication.listKey` | The list key of the currently authenticated user. Will be `undefined` for anonymous users.    |\n| `listKey`                | The key of the list being operated on.                                                        |\n| `operation`              | The CRUDA operation being performed (`'create'`, `'read'`, `'update'`, `'delete'`, `'auth'`). |\n| `originalInput`          | For `create` and `update` mutations, this is the data as passed in the mutation.              |\n| `gqlName`                | The name of the query or mutation which triggered the access check.                           |\n| `itemId`                 | The `id` of the item being updated/deleted in singular `update` and `delete` operations.      |\n| `itemIds`                | The `ids` of the items being updated/deleted in multiple `update` and `delete` operations.    |\n| `context`                | The `context` of the originating GraphQL operation.                                           |\n\nWhen resolving `StaticAccess`:\n\n- `true`: Allow access\n- `false`: Do not allow access\n\nDefinition of `access` operations:\n\n| Operation | Description                                            |\n| --------- | ------------------------------------------------------ |\n| `create`  | Ability to create new items in the list.               |\n| `read`    | Ability to view / fetch data on any items in the list. |\n| `update`  | Ability to alter data on any items in the list.        |\n| `delete`  | Ability to remove an item from the list.               |\n| `auth`    | Ability to use this list for authentication.           |\n\nWhen access is denied, the GraphQL response will contain an error with\n`type: 'AccessDeniedError'`, and `null` for the data.\n\n> **Note:** The `create` operation cannot be given `DeclarativeAccess` - it does\n> not make sense to do so and will throw an error if attempted. Additionally,\n> the `auth` operation control must be of type `StaticAccess`.\n\n### Shorthand static Boolean\n\nGreat for blanket access control for lists you want everyone/no one to see.\n\n```javascript\nkeystone.createList('User', {\n  access: true,\n});\n```\n\n> **Note:** When set to `false`, the list queries/mutations/types will not be included in the GraphQL schema.\n\n### Granular static Boolean\n\nUse when you need some more fine grained control over what actions users can perform.\n\n```javascript\nkeystone.createList('User', {\n  access: {\n    create: true,\n    read: true,\n    update: true,\n    delete: true,\n    auth: true,\n  },\n});\n```\n\n> **Note:** When set to `false`, the list queries/mutations/types exclusive to\n> that operation will not be included in the GraphQL schema. For example,\n> setting `create: false` will cause the `createXXXX` mutation to be excluded\n> from the schema, `update: false` will cause the `updateXXXX` mutation to be\n> excluded, and so on.\n\n### Shorthand imperative Boolean\n\nEnables turning access on/off based on the currently authenticated user.\n\n```javascript\nkeystone.createList('User', {\n  access: ({ authentication: { item, listKey } }) => {\n    return true;\n  },\n});\n```\n\n> **Note:** Even when returning `false`, the queries/mutations/types _will_ be\n> included in the GraphQL Schema.\n\n### Granular imperative Boolean\n\nUse when you need some more fine grained control over what actions some or all\nanonymous/authenticated users can perform.\n\n```javascript\nkeystone.createList('User', {\n  access: {\n    create: ({ authentication: { item, listKey } }) => true,\n    read: ({ authentication: { item, listKey } }) => true,\n    update: ({ authentication: { item, listKey } }) => true,\n    delete: ({ authentication: { item, listKey } }) => true,\n  },\n});\n```\n\n> **Note:** Even when returning `false`, the queries/mutations/types for that\n> operation _will_ be included in the GraphQL Schema. For example, `create: () => false` will still include the `createXXXX` mutation in\n> the GraphQL Schema, and so on.\n\n### GraphQLWhere\n\nIn the examples below, the `name_contains: 'k'` syntax matches the `UserWhereInput` GraphQL type for the list.\n\n1. For singular `read`/`update`/`delete` operations, when the `GraphQLWhere`\n   clause results in 0 items, an `AccessDeniedError` is returned.\n2. For batch `read` operations (eg; `query { allUsers }`), when the\n   `GraphQLWhere` clause results in 0 items returned, no error is returned.\n3. For `create` operations, an `AccessDeniedError` is returned if the operation\n   is set to / returns `false`\n\n#### Granular static `GraphQLWhere`\n\nUse when you need some more fine grained control over what items a user can\nperform actions on.\n\n```javascript\nkeystone.createList('User', {\n  access: {\n    create: true,\n    read: { name_contains: 'k' },\n    update: { name_contains: 'k' },\n    delete: { name_contains: 'k' },\n  },\n\n  fields: {\n    name: { type: Text },\n  },\n});\n```\n\n#### Granular imperative `GraphQLWhere`\n\nUse when you need some more fine grained control over which items _and_\nactions anonymous/authenticated users can perform.\n\n```javascript\nkeystone.createList('User', {\n  access: {\n    create: ({ authentication: { item, listKey } }) => true,\n    read: ({ authentication: { item, listKey } }) => ({\n      state_not: 'deactivated',\n    }),\n    update: ({ authentication: { item, listKey } }) => ({\n      state_not: 'deactivated',\n    }),\n    delete: ({ authentication: { item, listKey } }) => ({\n      state_not: 'deactivated',\n    }),\n  },\n\n  fields: {\n    state: {\n      type: Select,\n      options: ['active', 'deactivated'],\n      defaultValue: 'active',\n    },\n  },\n});\n```\n\n## Field level access control\n\nA key on the field config, `access` can be specified either as a single control,\ncovering all CRU operations, or as an object keyed by CRU operation names.\n\n> **Important:** Unlike List level access, it is not possible to specify a Declarative\n> _where_ clause for Field level access.\n\nThere are 2 ways to define the values of `access`, in order of flexibility:\n\n1. Static\n2. Imperative\n\n```typescript\ninterface AccessInput {\n  authentication: {\n    item?: {};\n    listKey?: string;\n  };\n  listKey?: string;\n  fieldKey?: string;\n  originalInput?: {};\n  existingItem?: {};\n  operation?: string;\n  gqlName?: string;\n  itemId?: string;\n  itemIds?: [string];\n  context?: {};\n}\n\ntype StaticAccess = boolean;\ntype ImperativeAccess = (arg: AccessInput) => boolean;\n\ninterface GranularAccess {\n  create?: StaticAccess | ImperativeAccess;\n  read?: StaticAccess | ImperativeAccess;\n  update?: StaticAccess | ImperativeAccess;\n}\n\ntype FieldConfig = {\n  access: StaticAccess | ImperativeAccess | GranularAccess;\n};\n```\n\n> **Note:** Fields do not have `delete` or `auth` access controls - these controls exists on\n> the list level only (it's not possible to _\"delete\"_ an existing field value -\n> only to modify it, and authentication is list-wide).\n\n| Property                 | Description                                                                                                   |\n| ------------------------ | ------------------------------------------------------------------------------------------------------------- |\n| `authentication`         | The currently authenticated user.                                                                             |\n| `authentication.item`    | The details of the current user. Will be `undefined` for anonymous users.                                     |\n| `authentication.listKey` | The list key of the currently authenticated user. Will be `undefined` for anonymous users.                    |\n| `listKey`                | The key of the list being operated on.                                                                        |\n| `fieldKey`               | The key of the field being operated on.                                                                       |\n| `originalInput`          | The data as passed in the mutation for `create` and `update` mutations (`undefined` for `read`).              |\n| `existingItem`           | The existing item this field belongs to for `update` mutations and `read` queries (`undefined` for `create`). |\n| `operation`              | The CRU operation being performed (`'create'`, `'read'`, `'update'`).                                         |\n| `gqlName`                | The name of the query or mutation which triggered the access check.                                           |\n| `itemId`                 | The `id` of the item being updated/deleted in singular `update` and `delete` operations.                      |\n| `itemIds`                | The `ids` of the items being updated/deleted in multiple `update` and `delete` operations.                    |\n| `context`                | The `context` of the originating GraphQL operation.                                                           |\n\nWhen defining `StaticAccess`:\n\n- `true`: Allow access\n- `false`: Do not allow access\n\nDefinition of `access` operations:\n\n| Operation | Description                                                     |\n| --------- | --------------------------------------------------------------- |\n| `create`  | Ability to set the value of the field when creating a new item. |\n| `read`    | Ability to view / fetch the value of this field on an item.     |\n| `update`  | Ability to alter the value of this field on an item.            |\n\nWhen access is denied, the GraphQL response will contain an error with `type: 'AccessDeniedError'`,\nand `null` for the field.\n\nLet's break it down into concrete examples:\n\n### Shorthand static Boolean\n\nGreat for blanket access control for fields you want everyone/no one to see.\n\n```javascript\nkeystone.createList('User', {\n  fields: {\n    name: {\n      type: Text,\n      access: true,\n    },\n  },\n});\n```\n\n> **Note:** When set to `false`, the list queries/mutations/types will not include\n> this field in the GraphQL schema.\n\n### Granular static Boolean\n\nUse when you need some more fine grained control over what actions users can\nperform with this field.\n\n```javascript\nkeystone.createList('User', {\n  fields: {\n    name: {\n      type: Text,\n      access: {\n        create: true,\n        read: true,\n        update: true,\n      },\n    },\n  },\n});\n```\n\n> **Note:** When set to `false`, this field will not be included in GraphQL\n> queries/mutations/types exclusively used by that operation.\n> Eg, setting `update: false` in the example above will remove the `name` field from the\n> `UserUpdateInput` type but may still include the field in `UserCreateInput` for example.\n\n### Shorthand imperative Boolean\n\nEnables turning access on/off based on the currently authenticated user.\n\n```javascript\nkeystone.createList('User', {\n  fields: {\n    name: {\n      type: Text,\n      access: ({ authentication: { item, listKey }, existingItem }) => {\n        return true;\n      },\n    },\n  },\n});\n```\n\n> **Note:** Even when returning `false`, the queries/mutations/types _will_\n> include the field in the GraphQL Schema.\n\n### Granular imperative Boolean\n\nUse when you need some more fine grained control over what actions some or all\nanonymous/authenticated users can perform.\n\n```javascript\nkeystone.createList('User', {\n  access: {\n    create: ({ authentication: { item, listKey }, existingItem }) => true,\n    read: ({ authentication: { item, listKey }, existingItem }) => true,\n    update: ({ authentication: { item, listKey }, existingItem }) => true,\n  },\n});\n```\n\n> **Note:** Even when returning `false`, this field _will_ be included in GraphQL\n> queries/mutations/types exclusively used by that operation.\n> Eg, setting `update: () => false` in the example above will still include the\n> `name` field in the `UserUpdateInput` type.\n\n## Custom schema access control\n\n[Custom GraphQL schema](https://www.keystonejs.com/keystonejs/keystone/#extendgraphqlschemaconfig) can also be access-controlled.\nEach custom type, query, and mutation accepts an `access` key.\n\nThere are two ways to define the value of `access`:\n\n1. Static\n2. Imperative\n\n```typescript\ninterface AccessInput {\n  item {};\n  args {} ;\n  context: {};\n  info: {};\n  authentication: {\n    item?: {};\n    listKey?: string;\n  };\n  gqlName: string;\n}\n\ntype StaticAccess = boolean;\ntype ImperativeAccess = (arg: AccessInput) => boolean;\n\ntype CustomOperationConfig = {\n  access: StaticAccess | ImperativeAccess;\n};\n```\n\n### Static boolean\n\n```javascript\nkeystone.extendGraphQLSchema({\n  queries: [\n    {\n      schema: 'getUserByName(name: String!): Boolean',\n      resolver: async (item, args, context, info, { query, access }) => {...},\n      access: true,\n    },\n  ],\n});\n```\n\n> Useful if default custom access controls are set to `false`.\n\n_NOTE:_ When set to `false`, the custom queries/mutations/types will not be included in the GraphQL schema.\n\n### Imperative boolean\n\n```javascript\nkeystone.extendGraphQLSchema({\n  queries: [\n    {\n      schema: 'getUserByName(name: String!): Boolean',\n      resolver: async (item, args, context, info, { query, access }) => {...},\n      access: async ({ item, args, context, info, authentication: { item: authedItem, listKey }, gqlName }) => {\n        return true;\n      },\n    },\n  ],\n});\n```\n\n> Enables turning access on/off based on the currently authenticated user.\n\n_NOTE:_ Even when returning `false`, the custom queries/mutations/types _will_ be included in the GraphQL Schema.\n"}},"__N_SSG":true}