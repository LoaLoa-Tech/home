{"pageProps":{"markdownPost":{"name":null,"url":null,"content":"---\nid: hooks-rules\ntitle: Rules of Hooks\npermalink: docs/hooks-rules.html\nnext: hooks-custom.html\nprev: hooks-effect.html\n---\n\n*Hooks* are a new addition in React 16.8. They let you use state and other React features without writing a class.\n\nHooks are JavaScript functions, but you need to follow two rules when using them. We provide a [linter plugin](https://www.npmjs.com/package/eslint-plugin-react-hooks) to enforce these rules automatically:\n\n### Only Call Hooks at the Top Level {#only-call-hooks-at-the-top-level}\n\n**Don't call Hooks inside loops, conditions, or nested functions.** Instead, always use Hooks at the top level of your React function. By following this rule, you ensure that Hooks are called in the same order each time a component renders. That's what allows React to correctly preserve the state of Hooks between multiple `useState` and `useEffect` calls. (If you're curious, we'll explain this in depth [below](#explanation).)\n\n### Only Call Hooks from React Functions {#only-call-hooks-from-react-functions}\n\n**Don't call Hooks from regular JavaScript functions.** Instead, you can:\n\n* ‚úÖ Call Hooks from React function components.\n* ‚úÖ Call Hooks from custom Hooks (we'll learn about them [on the next page](/docs/hooks-custom.html)).\n\nBy following this rule, you ensure that all stateful logic in a component is clearly visible from its source code.\n\n## ESLint Plugin {#eslint-plugin}\n\nWe released an ESLint plugin called [`eslint-plugin-react-hooks`](https://www.npmjs.com/package/eslint-plugin-react-hooks) that enforces these two rules. You can add this plugin to your project if you'd like to try it:\n\nThis plugin is included by default in [Create React App](/docs/create-a-new-react-app.html#create-react-app).\n\n```bash\nnpm install eslint-plugin-react-hooks --save-dev\n```\n\n```js\n// Your ESLint configuration\n{\n  \"plugins\": [\n    // ...\n    \"react-hooks\"\n  ],\n  \"rules\": {\n    // ...\n    \"react-hooks/rules-of-hooks\": \"error\", // Checks rules of Hooks\n    \"react-hooks/exhaustive-deps\": \"warn\" // Checks effect dependencies\n  }\n}\n```\n\n**You can skip to the next page explaining how to write [your own Hooks](/docs/hooks-custom.html) now.** On this page, we'll continue by explaining the reasoning behind these rules.\n\n## Explanation {#explanation}\n\nAs we [learned earlier](/docs/hooks-state.html#tip-using-multiple-state-variables), we can use multiple State or Effect Hooks in a single component:\n\n```js\nfunction Form() {\n  // 1. Use the name state variable\n  const [name, setName] = useState('Mary');\n\n  // 2. Use an effect for persisting the form\n  useEffect(function persistForm() {\n    localStorage.setItem('formData', name);\n  });\n\n  // 3. Use the surname state variable\n  const [surname, setSurname] = useState('Poppins');\n\n  // 4. Use an effect for updating the title\n  useEffect(function updateTitle() {\n    document.title = name + ' ' + surname;\n  });\n\n  // ...\n}\n```\n\nSo how does React know which state corresponds to which `useState` call? The answer is that **React relies on the order in which Hooks are called**. Our example works because the order of the Hook calls is the same on every render:\n\n```js\n// ------------\n// First render\n// ------------\nuseState('Mary')           // 1. Initialize the name state variable with 'Mary'\nuseEffect(persistForm)     // 2. Add an effect for persisting the form\nuseState('Poppins')        // 3. Initialize the surname state variable with 'Poppins'\nuseEffect(updateTitle)     // 4. Add an effect for updating the title\n\n// -------------\n// Second render\n// -------------\nuseState('Mary')           // 1. Read the name state variable (argument is ignored)\nuseEffect(persistForm)     // 2. Replace the effect for persisting the form\nuseState('Poppins')        // 3. Read the surname state variable (argument is ignored)\nuseEffect(updateTitle)     // 4. Replace the effect for updating the title\n\n// ...\n```\n\nAs long as the order of the Hook calls is the same between renders, React can associate some local state with each of them. But what happens if we put a Hook call (for example, the `persistForm` effect) inside a condition?\n\n```js\n  // üî¥ We're breaking the first rule by using a Hook in a condition\n  if (name !== '') {\n    useEffect(function persistForm() {\n      localStorage.setItem('formData', name);\n    });\n  }\n```\n\nThe `name !== ''` condition is `true` on the first render, so we run this Hook. However, on the next render the user might clear the form, making the condition `false`. Now that we skip this Hook during rendering, the order of the Hook calls becomes different:\n\n```js\nuseState('Mary')           // 1. Read the name state variable (argument is ignored)\n// useEffect(persistForm)  // üî¥ This Hook was skipped!\nuseState('Poppins')        // üî¥ 2 (but was 3). Fail to read the surname state variable\nuseEffect(updateTitle)     // üî¥ 3 (but was 4). Fail to replace the effect\n```\n\nReact wouldn't know what to return for the second `useState` Hook call. React expected that the second Hook call in this component corresponds to the `persistForm` effect, just like during the previous render, but it doesn't anymore. From that point, every next Hook call after the one we skipped would also shift by one, leading to bugs.\n\n**This is why Hooks must be called on the top level of our components.** If we want to run an effect conditionally, we can put that condition *inside* our Hook:\n\n```js\n  useEffect(function persistForm() {\n    // üëç We're not breaking the first rule anymore\n    if (name !== '') {\n      localStorage.setItem('formData', name);\n    }\n  });\n```\n\n**Note that you don't need to worry about this problem if you use the [provided lint rule](https://www.npmjs.com/package/eslint-plugin-react-hooks).** But now you also know *why* Hooks work this way, and which issues the rule is preventing.\n\n## Next Steps {#next-steps}\n\nFinally, we're ready to learn about [writing your own Hooks](/docs/hooks-custom.html)! Custom Hooks let you combine Hooks provided by React into your own abstractions, and reuse common stateful logic between different components.\n"}},"__N_SSG":true}