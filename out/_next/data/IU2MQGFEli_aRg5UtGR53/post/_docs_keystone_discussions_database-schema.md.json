{"pageProps":{"markdownPost":{"name":null,"url":null,"content":"<!--[meta]\nsection: discussions\ntitle: Database schema\n[meta]-->\n\n# Database schema\n\nKeystone models its data using `Lists`, which comprise of `Fields`.\nIn order to store data we need to translate the Keystone data model into an appropriate form for the underlying data store.\nThis transformation is handled by the [database adapters](/docs/quick-start/adapters.md).\n\nThis transformation is generally reasonably simple.\nA `List` called `User` in Keystone will have table called `Users` in PostgreSQL or a collection called `users` in MongoDB.\nFor most field types there is also a one to to correspondence between a Keystone `Field` and a PostgreSQL column or MongoDB field.\nEach field type is responsible for articulating the exact correspondence, which includes the storage types and any auxiliary data that needs to be stored.\n\nThe most complicated aspect of the database schema is the representation of relationships.\nTo understand the storage of relationships you should first make sure you understand the basic ideas behind [Keystone relationships](/docs/discussions/relationships.md).\n\n## One-to-many\n\n```javascript\nkeystone.createList('User', {\n  fields: {\n    name: { type: Text },\n  },\n});\n\nkeystone.createList('Post', {\n  fields: {\n    title: { type: Text },\n    content: { type: Text },\n    author: { type: Relationship, ref: 'User', many: false },\n  },\n});\n```\n\nIf we consider the above `one-to-many` relationship we know that each `Post` has a single `author` of type `User`.\nThis means that we `Post` needs to store a reference to a single `User`.\n\nIn PostgreSQL this is stored as a [foreign key column](https://www.postgresql.org/docs/12/ddl-constraints.html#DDL-CONSTRAINTS-FK) called `author` on the `Posts` table,\nIn MongoDB it is stored as a field called `author` on the `posts` collection with type `ObjectID`.\n\nThe two-sided cases is handled identically to the one-sided case.\n\n## Many-to-many\n\n```javascript\nkeystone.createList('User', {\n  fields: {\n    name: { type: Text },\n  },\n});\n\nkeystone.createList('Post', {\n  fields: {\n    title: { type: Text },\n    content: { type: Text },\n    authors: { type: Relationship, ref: 'User', many: true },\n  },\n});\n```\n\nIf we consider the above `many-to-many` relationship we know that each `Post` has multiple `authors` of type `User`.\nThis means that `Post` needs to store multiple references to `Users`, and also each `User` can be referenced by multiple `Posts`.\n\nTo store this information we use a join table with two columns.\nOne column holds a reference to `Posts` and the other holds a reference to `Users`.\nIn PostgreSQL this is implemented as a table where the contents of each column is a [foreign key](https://www.postgresql.org/docs/12/ddl-constraints.html#DDL-CONSTRAINTS-FK) referencing the respective table.\n\nIn MongoDB this is implemented as a collection where the contents of each field is an `ObjectID` referencing the respective [document](https://docs.mongodb.com/manual/core/document/). The above many-to-many example would result in a collection named `post_authors_manies` with a joining document of this format:\n\n```javascript\n{\n  \"_id\": ObjectID,\n  \"Post_left_id\": ObjectID,\n  \"User_right_id\": ObjectID,\n}\n```\n\nThe two-sided cases is handled using the same pattern, however the generated table/collection and column/fields names will be different.\n\n## One-to-one\n\n```javascript\nkeystone.createList('User', {\n  fields: {\n    name: { type: Text },\n    post: { type: Relationship, ref: 'Post.author', many: false },\n  },\n});\n\nkeystone.createList('Post', {\n  fields: {\n    title: { type: Text },\n    content: { type: Text },\n    author: { type: Relationship, ref: 'User.post', many: false },\n  },\n});\n```\n\nIf we consider the above `one-to-one` relationship we know that each `Post` has a single `author`, and each `User` is the author of a single `Post`.\nThis is similar to the `one-to-many` case, however now because of the symmetry of the configuration it is possible to store the data on either the `Post` or `User` table.\n\nTo break this symmetry we pick the list with the name that comes first alphabetically, so in this case `Post`.\nJust as in the `one-to-many` case, in PostgreSQL the data is stored as a [foreign key column](https://www.postgresql.org/docs/12/ddl-constraints.html#DDL-CONSTRAINTS-FK) called `author` on the `Posts` table.\nIn MongoDB it is stored as a field called `author` on the `posts` collection with type `ObjectID`.\n"}},"__N_SSG":true}