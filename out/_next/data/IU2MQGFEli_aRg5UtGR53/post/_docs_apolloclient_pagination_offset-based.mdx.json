{"pageProps":{"markdownPost":{"name":null,"url":null,"content":"---\ntitle: 'Offset-based pagination'\nsidebar_title: 'Offset-based'\n---\n\n> We recommend reading [Core pagination API](./core-api) before learning about considerations specific to offset-based pagination.\n\nOffset-based pagination works well for immutable lists, or lists whose element positions are not expected to change, since moving or removing elements could alter the offsets of the elements in the list, sometimes causing elements to be skipped or duplicated if the list is modified on the server between page requests.\n\nAlthough offset-based pagination has these shortcomings, it is a common pattern found in many applications, in part because it is straightforward to implement on the backend. In SQL, for example, numbered pages can easily be generated by using [OFFSET and LIMIT](https://www.postgresql.org/docs/8.2/static/queries-limit.html).\n\n## The `offsetLimitPagination` helper\n\nCommon pagination strategies can be abstracted away into helper functions, such as the `offsetLimitPagination` function that `@apollo/client/utilities` provides:\n\n```js\nimport { offsetLimitPagination } from \"@apollo/client/utilities\"\n\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Query: {\n      fields: {\n        feed: offsetLimitPagination([\"type\"]),\n      },\n    },\n  },\n});\n```\n\nThe `[\"type\"]` argument here specifies the `keyArgs` to be used for this field policy. By default, `offsetLimitPagination` uses `keyArgs: false`.\n\nIf you set the field policy above for `Query.feed`, then you can use `fetchMore` with `useQuery` like so:\n\n```jsx\nconst FeedData({ type = \"PUBLIC\" }) {\n  const { loading, data, fetchMore } = useQuery(FEED_QUERY, {\n    variables: {\n      type: type.toUpperCase(),\n      offset: 0,\n      limit: 10\n    },\n  });\n\n  // If you want your component to rerender with loading:true whenever\n  // fetchMore is called, add notifyOnNetworkStatusChange:true to the\n  // options you pass to useQuery above.\n  if (loading) return <Loading/>;\n\n  return (\n    <Feed\n      entries={data.feed || []}\n      onLoadMore={() => fetchMore({\n        variables: {\n          offset: data.feed.length\n        },\n      })}\n    />\n  );\n}\n```\n\nBy default, `fetchMore` uses the original `query` and `variables`, so we only need to pass the variable that is changing: the `offset`. Once the new data is returned from the server, it will be automatically merged with any existing `Query.feed` data in the cache, which will cause `useQuery` to rerender with the expanded list of data.\n\nThis style of `fetchMore` usage assumes you want your component to receive the entire available list each time it renders, containing data from all pages received so far. This is a [non-paginated `read` function](./core-api/#non-paginated-read-functions).\n\nIf you are using a `Query.feed` field policy containing a `read` function that uses `args.offset` and `args.limit` to return a single page of data, the code above will still work, but you may be surprised that your component does not automatically rerender with additional data (beyond the first page) after `fetchMore` finishes. This happens because the original `variables: { offset: 0, limit: 10 }` are still in effect, and the first 10 items were not changed by the `fetchMore` call, so your `read` function returns the same page as before.\n\nBefore you can fix this problem, you first need to think about the behavior that you want. Should your component continue displaying only the first page, or should it now display the page we just received, or should it display the entire list of known data? Regardless of which option you prefer, these alternatives all boil down to the `variables` you pass to `useQuery`, which must change if you want your component to render different data.\n\nFor example, to display all the data received so far, you could modify the previous example as follows:\n\n```jsx\nconst FeedData({ type = \"PUBLIC\" }) {\n  const [limit, setLimit] = useState(10);\n  const { loading, data, fetchMore } = useQuery(FEED_QUERY, {\n    variables: {\n      type: type.toUpperCase(),\n      offset: 0,\n      limit,\n    },\n  });\n\n  if (loading) return <Loading/>;\n\n  return (\n    <Feed\n      entries={data.feed || []}\n      onLoadMore={() => {\n        const currentLength = data.feed.length;\n        fetchMore({\n          variables: {\n            offset: currentLength,\n            limit: 10,\n          },\n        }).then(fetchMoreResult => {\n          // Update variables.limit for the original query to include\n          // the newly added feed items.\n          setLimit(currentLength + fetchMoreResult.data.feed.length);\n        });\n      }\n    />\n  );\n}\n```\n\nThis code uses a React `useState` Hook to store the current `limit` value, which it updates by calling `setLimit` in a callback attached to the `Promise` returned by `fetchMore`.\n\nYou could store `offset` in a React `useState` Hook as well, if you need the `offset` to change. Exactly when and how these `variables` change is up to your component, and may not always be the result of calling `fetchMore`, so it makes sense to use React component state to store these variable values.\n\n> If you are not using React and `useQuery`, the `ObservableQuery` object returned by `client.watchQuery` has a method called `setVariables` that you can call to update the original variables.\n\nBecause `fetchMore` requires some extra work to update the original variables if you're using a `read` function that is sensitive to those variables (the second kind of `read` function), it's fair to say `fetchMore` encourages the first kind of `read` function, which simply returns all available data.\n\nHowever, now that you understand your options, there's nothing wrong with moving read-time pagination logic out of your application code and into your field `read` functions. Both kinds of `read` functions have their uses, and both can be made to work with `fetchMore`.\n"}},"__N_SSG":true}