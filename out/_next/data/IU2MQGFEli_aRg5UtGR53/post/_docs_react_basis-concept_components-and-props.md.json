{"pageProps":{"markdownPost":{"name":null,"url":null,"content":"---\nid: components-and-props\ntitle: Components and Props\npermalink: docs/components-and-props.html\nredirect_from:\n  - \"docs/reusable-components.html\"\n  - \"docs/reusable-components-zh-CN.html\"\n  - \"docs/transferring-props.html\"\n  - \"docs/transferring-props-it-IT.html\"\n  - \"docs/transferring-props-ja-JP.html\"\n  - \"docs/transferring-props-ko-KR.html\"\n  - \"docs/transferring-props-zh-CN.html\"\n  - \"tips/props-in-getInitialState-as-anti-pattern.html\"\n  - \"tips/communicate-between-components.html\"\nprev: rendering-elements.html\nnext: state-and-lifecycle.html\n---\n\nComponents let you split the UI into independent, reusable pieces, and think about each piece in isolation. This page provides an introduction to the idea of components. You can find a [detailed component API reference here](/docs/react-component.html).\n\nConceptually, components are like JavaScript functions. They accept arbitrary inputs (called \"props\") and return React elements describing what should appear on the screen.\n\n## Function and Class Components {#function-and-class-components}\n\nThe simplest way to define a component is to write a JavaScript function:\n\n```js\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n```\n\nThis function is a valid React component because it accepts a single \"props\" (which stands for properties) object argument with data and returns a React element. We call such components \"function components\" because they are literally JavaScript functions.\n\nYou can also use an [ES6 class](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes) to define a component:\n\n```js\nclass Welcome extends React.Component {\n  render() {\n    return <h1>Hello, {this.props.name}</h1>;\n  }\n}\n```\n\nThe above two components are equivalent from React's point of view.\n\nFunction and Class components both have some additional features that we will discuss in the [next sections](/docs/state-and-lifecycle.html).\n\n## Rendering a Component {#rendering-a-component}\n\nPreviously, we only encountered React elements that represent DOM tags:\n\n```js\nconst element = <div />;\n```\n\nHowever, elements can also represent user-defined components:\n\n```js\nconst element = <Welcome name=\"Sara\" />;\n```\n\nWhen React sees an element representing a user-defined component, it passes JSX attributes and children to this component as a single object. We call this object \"props\".\n\nFor example, this code renders \"Hello, Sara\" on the page:\n\n```js{1,5}\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n\nconst element = <Welcome name=\"Sara\" />;\nReactDOM.render(\n  element,\n  document.getElementById('root')\n);\n```\n\n[](codepen://components-and-props/rendering-a-component)\n\nLet's recap what happens in this example:\n\n1. We call `ReactDOM.render()` with the `<Welcome name=\"Sara\" />` element.\n2. React calls the `Welcome` component with `{name: 'Sara'}` as the props.\n3. Our `Welcome` component returns a `<h1>Hello, Sara</h1>` element as the result.\n4. React DOM efficiently updates the DOM to match `<h1>Hello, Sara</h1>`.\n\n>**Note:** Always start component names with a capital letter.\n>\n>React treats components starting with lowercase letters as DOM tags. For example, `<div />` represents an HTML div tag, but `<Welcome />` represents a component and requires `Welcome` to be in scope.\n>\n>To learn more about the reasoning behind this convention, please read [JSX In Depth](/docs/jsx-in-depth.html#user-defined-components-must-be-capitalized).\n\n## Composing Components {#composing-components}\n\nComponents can refer to other components in their output. This lets us use the same component abstraction for any level of detail. A button, a form, a dialog, a screen: in React apps, all those are commonly expressed as components.\n\nFor example, we can create an `App` component that renders `Welcome` many times:\n\n```js{8-10}\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n\nfunction App() {\n  return (\n    <div>\n      <Welcome name=\"Sara\" />\n      <Welcome name=\"Cahal\" />\n      <Welcome name=\"Edite\" />\n    </div>\n  );\n}\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n```\n\n[](codepen://components-and-props/composing-components)\n\nTypically, new React apps have a single `App` component at the very top. However, if you integrate React into an existing app, you might start bottom-up with a small component like `Button` and gradually work your way to the top of the view hierarchy.\n\n## Extracting Components {#extracting-components}\n\nDon't be afraid to split components into smaller components.\n\nFor example, consider this `Comment` component:\n\n```js\nfunction Comment(props) {\n  return (\n    <div className=\"Comment\">\n      <div className=\"UserInfo\">\n        <img className=\"Avatar\"\n          src={props.author.avatarUrl}\n          alt={props.author.name}\n        />\n        <div className=\"UserInfo-name\">\n          {props.author.name}\n        </div>\n      </div>\n      <div className=\"Comment-text\">\n        {props.text}\n      </div>\n      <div className=\"Comment-date\">\n        {formatDate(props.date)}\n      </div>\n    </div>\n  );\n}\n```\n\n[](codepen://components-and-props/extracting-components)\n\nIt accepts `author` (an object), `text` (a string), and `date` (a date) as props, and describes a comment on a social media website.\n\nThis component can be tricky to change because of all the nesting, and it is also hard to reuse individual parts of it. Let's extract a few components from it.\n\nFirst, we will extract `Avatar`:\n\n```js{3-6}\nfunction Avatar(props) {\n  return (\n    <img className=\"Avatar\"\n      src={props.user.avatarUrl}\n      alt={props.user.name}\n    />\n  );\n}\n```\n\nThe `Avatar` doesn't need to know that it is being rendered inside a `Comment`. This is why we have given its prop a more generic name: `user` rather than `author`.\n\nWe recommend naming props from the component's own point of view rather than the context in which it is being used.\n\nWe can now simplify `Comment` a tiny bit:\n\n```js{5}\nfunction Comment(props) {\n  return (\n    <div className=\"Comment\">\n      <div className=\"UserInfo\">\n        <Avatar user={props.author} />\n        <div className=\"UserInfo-name\">\n          {props.author.name}\n        </div>\n      </div>\n      <div className=\"Comment-text\">\n        {props.text}\n      </div>\n      <div className=\"Comment-date\">\n        {formatDate(props.date)}\n      </div>\n    </div>\n  );\n}\n```\n\nNext, we will extract a `UserInfo` component that renders an `Avatar` next to the user's name:\n\n```js{3-8}\nfunction UserInfo(props) {\n  return (\n    <div className=\"UserInfo\">\n      <Avatar user={props.user} />\n      <div className=\"UserInfo-name\">\n        {props.user.name}\n      </div>\n    </div>\n  );\n}\n```\n\nThis lets us simplify `Comment` even further:\n\n```js{4}\nfunction Comment(props) {\n  return (\n    <div className=\"Comment\">\n      <UserInfo user={props.author} />\n      <div className=\"Comment-text\">\n        {props.text}\n      </div>\n      <div className=\"Comment-date\">\n        {formatDate(props.date)}\n      </div>\n    </div>\n  );\n}\n```\n\n[](codepen://components-and-props/extracting-components-continued)\n\nExtracting components might seem like grunt work at first, but having a palette of reusable components pays off in larger apps. A good rule of thumb is that if a part of your UI is used several times (`Button`, `Panel`, `Avatar`), or is complex enough on its own (`App`, `FeedStory`, `Comment`), it is a good candidate to be extracted to a separate component.\n\n## Props are Read-Only {#props-are-read-only}\n\nWhether you declare a component [as a function or a class](#function-and-class-components), it must never modify its own props. Consider this `sum` function:\n\n```js\nfunction sum(a, b) {\n  return a + b;\n}\n```\n\nSuch functions are called [\"pure\"](https://en.wikipedia.org/wiki/Pure_function) because they do not attempt to change their inputs, and always return the same result for the same inputs.\n\nIn contrast, this function is impure because it changes its own input:\n\n```js\nfunction withdraw(account, amount) {\n  account.total -= amount;\n}\n```\n\nReact is pretty flexible but it has a single strict rule:\n\n**All React components must act like pure functions with respect to their props.**\n\nOf course, application UIs are dynamic and change over time. In the [next section](/docs/state-and-lifecycle.html), we will introduce a new concept of \"state\". State allows React components to change their output over time in response to user actions, network responses, and anything else, without violating this rule.\n"}},"__N_SSG":true}