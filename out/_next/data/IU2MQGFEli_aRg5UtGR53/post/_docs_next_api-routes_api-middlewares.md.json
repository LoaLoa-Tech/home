{"pageProps":{"markdownPost":{"name":null,"url":null,"content":"---\ndescription: API Routes provide built-in middlewares that parse the incoming request. Learn more about them here.\n---\n\n# API Middlewares\n\n<details open>\n  <summary><b>Examples</b></summary>\n  <ul>\n    <li><a href=\"https://github.com/vercel/next.js/tree/canary/examples/api-routes-middleware\">API Routes with middleware</a></li>\n    <li><a href=\"https://github.com/vercel/next.js/tree/canary/examples/api-routes-cors\">API Routes with CORS</a></li>\n  </ul>\n</details>\n\nAPI routes provide built in middlewares which parse the incoming request (`req`). Those middlewares are:\n\n- `req.cookies` - An object containing the cookies sent by the request. Defaults to `{}`\n- `req.query` - An object containing the [query string](https://en.wikipedia.org/wiki/Query_string). Defaults to `{}`\n- `req.body` - An object containing the body parsed by `content-type`, or `null` if no body was sent\n\n## Custom config\n\nEvery API route can export a `config` object to change the default configs, which are the following:\n\n```js\nexport const config = {\n  api: {\n    bodyParser: {\n      sizeLimit: '1mb',\n    },\n  },\n}\n```\n\nThe `api` object includes all configs available for API routes.\n\n`bodyParser` Enables body parsing, you can disable it if you want to consume it as a `Stream`:\n\n```js\nexport const config = {\n  api: {\n    bodyParser: false,\n  },\n}\n```\n\n`bodyParser.sizeLimit` is the maximum size allowed for the parsed body, in any format supported by [bytes](https://github.com/visionmedia/bytes.js), like so:\n\n```js\nexport const config = {\n  api: {\n    bodyParser: {\n      sizeLimit: '500kb',\n    },\n  },\n}\n```\n\n`externalResolver` is an explicit flag that tells the server that this route is being handled by an external resolver like _express_ or _connect_. Enabling this option disables warnings for unresolved requests.\n\n```js\nexport const config = {\n  api: {\n    externalResolver: true,\n  },\n}\n```\n\n## Connect/Express middleware support\n\nYou can also use [Connect](https://github.com/senchalabs/connect) compatible middleware.\n\nFor example, [configuring CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) for your API endpoint can be done leveraging the [cors](https://www.npmjs.com/package/cors) package.\n\nFirst, install `cors`:\n\n```bash\nnpm i cors\n# or\nyarn add cors\n```\n\nNow, let's add `cors` to the API route:\n\n```js\nimport Cors from 'cors'\n\n// Initializing the cors middleware\nconst cors = Cors({\n  methods: ['GET', 'HEAD'],\n})\n\n// Helper method to wait for a middleware to execute before continuing\n// And to throw an error when an error happens in a middleware\nfunction runMiddleware(req, res, fn) {\n  return new Promise((resolve, reject) => {\n    fn(req, res, (result) => {\n      if (result instanceof Error) {\n        return reject(result)\n      }\n\n      return resolve(result)\n    })\n  })\n}\n\nasync function handler(req, res) {\n  // Run the middleware\n  await runMiddleware(req, res, cors)\n\n  // Rest of the API logic\n  res.json({ message: 'Hello Everyone!' })\n}\n\nexport default handler\n```\n\n> Go to the [API Routes with CORS](https://github.com/vercel/next.js/tree/canary/examples/api-routes-cors) example to see the finished app\n\n## Extending the `req`/`res` objects with TypeScript\n\nFor better type-safety, it is not recommended to extend the `req` and `res` objects. Instead, use pure functions to work with them:\n\n```ts\n// utils/cookies.ts\n\nimport { serialize, CookieSerializeOptions } from 'cookie'\nimport { NextApiResponse } from 'next'\n\n/**\n * This sets `cookie` using the `res` object\n */\n\nexport const setCookie = (\n  res: NextApiResponse,\n  name: string,\n  value: unknown,\n  options: CookieSerializeOptions = {}\n) => {\n  const stringValue =\n    typeof value === 'object' ? 'j:' + JSON.stringify(value) : String(value)\n\n  if ('maxAge' in options) {\n    options.expires = new Date(Date.now() + options.maxAge)\n    options.maxAge /= 1000\n  }\n\n  res.setHeader('Set-Cookie', serialize(name, String(stringValue), options))\n}\n\n// pages/api/cookies.ts\n\nimport { NextApiRequest, NextApiResponse } from 'next'\nimport { setCookie } from '../../utils/cookies'\n\nconst handler = (req: NextApiRequest, res: NextApiResponse) => {\n  // Calling our pure function using the `res` object, it will add the `set-cookie` header\n  setCookie(res, 'Next.js', 'api-middleware!')\n  // Return the `set-cookie` header so we can display it in the browser and show that it works!\n  res.end(res.getHeader('Set-Cookie'))\n}\n\nexport default handler\n```\n\nIf you can't avoid these objects from being extended, you have to create your own type to include the extra properties:\n\n```ts\n// pages/api/foo.ts\n\nimport { NextApiRequest, NextApiResponse } from 'next'\nimport { withFoo } from 'external-lib-foo'\n\ntype NextApiRequestWithFoo = NextApiRequest & {\n  foo: (bar: string) => void\n}\n\nconst handler = (req: NextApiRequestWithFoo, res: NextApiResponse) => {\n  req.foo('bar') // we can now use `req.foo` without type errors\n  res.end('ok')\n}\n\nexport default withFoo(handler)\n```\n\nKeep in mind this is not safe since the code will still compile even if you remove `withFoo()` from the export.\n"}},"__N_SSG":true}