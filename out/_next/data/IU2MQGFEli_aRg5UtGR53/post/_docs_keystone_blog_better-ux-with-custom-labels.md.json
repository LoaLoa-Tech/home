{"pageProps":{"markdownPost":{"name":null,"url":null,"content":"<!--[meta]\nsection: blog\ntitle: Using custom labels to improve Author Experience\ndate: 2020-10-12\nauthor: Noviny\norder: 0.3\n[meta]-->\n\nIn Keystone's Admin UI, we want to make it easy to display items and get a feel for your content at a glance. One of the important things here is being able to have meaningful labels for each item in your database when you're viewing a bunch of those items as a list. To do this, we have a feature called `labelResolver`.\n\nIn this post, we'll walk you through the default behaviour for labels, how to customise the label, and even how to use information from a relationship in the label.\n\n## What is the Label?\n\nAlthough Keystone has no strong opinions about what fields might be in any given list, it needs a consistent way to identify items to users of the Admin UI. Two examples of this are in the list view, and how items are displayed in relationship fields.\n\nThis is where the label comes in. It's a built-in, read-only string field that Keystone adds to the schema for each list called `_label_`, and it gives us a predictable way of querying a human-readable reference for what an item 'is' in Keystone.\n\nLabels have default behaviour, but importantly you can customise them to create a better user experience for content authors and data managers using the Keystone Admin UI.\n\n## Using the Name Field\n\nBy default, the label uses the `name` field of an item. For example, with the following user list schema:\n\n```js\nconst User = {\n  fields: {\n    name: { type: Text },\n    email: { type: Text, isUnique: true },\n    dob: {\n      type: CalendarDay,\n      format: 'do MMMM yyyy',\n      dateFrom: '1901-01-01',\n      dateTo: formatISO(new Date(), { representation: 'date' }),\n    },\n    password: { type: Password },\n  },\n};\n```\n\nThe Admin UI will look like this:\n\n![Alt Text](https://raw.githubusercontent.com/Noviny/images/master/blog1.png)\n\n## Using Another Field\n\nIn some circumstances, `name` may not be the best field to use, or it may not even exist. Say we have a new list `Post`, which we have set up like this:\n\n```js\nconst Post = {\n  fields: {\n    title: { type: Text },\n    status: {\n      type: Select,\n      defaultValue: 'draft',\n      options: [\n        { label: 'Draft', value: 'draft' },\n        { label: 'Published', value: 'published' },\n      ],\n    },\n    author: {\n      type: AuthedRelationship,\n      ref: 'User',\n      isRequired: true,\n    },\n    body: { type: Wysiwyg },\n    // and probably some other fields we won't use here\n  },\n};\n```\n\nIn our posts, we don't have a `name` field - the primary identifying field `title`. As there's no `name` field, label will use the ID, which will give us something like:\n\n![Alt Text](https://raw.githubusercontent.com/Noviny/images/master/blog2-2.png)\n\nNot super human friendly.\n\nWe could rename title to name, but that's not what we want. What we _do_ want is to make the label use the title for display. For this, we can add a `labelResolver` to our post field\n\n```js\nconst Post = {\n  fields: {\n    title: { type: Text },\n    // and the rest of the fields too\n  },\n  labelResolver: item => item.title,\n};\n```\n\nNow we get the much more friendly:\n\n![Alt Text](https://raw.githubusercontent.com/Noviny/images/master/blog3-3.png)\n\n## Providing extra information in the label\n\nWhile sometimes you may just want to use another field, other times though there may be other bits of information that are always pertinent. Say for our post above, we have a status field, and we want to display in the label whether something is in `draft` mode or not.\n\nHere we can modify our `labelResolver` to add in this extra detail.\n\n```js\nconst Post = {\n  fields: {\n    title: { type: Text },\n    status: {\n      type: Select,\n      defaultValue: 'draft',\n      options: [\n        { label: 'Draft', value: 'draft' },\n        { label: 'Published', value: 'published' },\n      ],\n    },\n    // and the rest of the fields too\n  },\n  labelResolver: item => `${item.status === 'draft' ? 'DRAFT - ' : ''}` + item.title,\n};\n```\n\nwhich means our posts now appear as:\n\n![Alt Text](https://raw.githubusercontent.com/Noviny/images/master/blog4-4.png)\n\n> Note: The `label` for items in a public list is always public! Even if other bits of the item may be private. We recommend when picking what to put in a label, make sure nothing private (like email) is included.\n\n## Using Another List\n\nGreat, we've got a fairly robust `Post` label, but we want to extend it just a little bit more - like adding the author's name in as well. This information isn't actually found on the item, so we're going to need to fetch it.\n\nNot to worry though, `labelResolver` can easily be made async, and we can fetch other information from related items. We can modify our `labelResolver` to:\n\n```js\nconst Post = {\n  fields: {\n    author: {\n      type: AuthedRelationship,\n      ref: 'User',\n      isRequired: true,\n    },\n    // and the rest of the fields too\n  },\n  labelResolver: async item => {\n    const { data } = await keystone.executeGraphQL({\n      query: `query {\n          User(where: {id: \"${item.author}\" }) {\n            name\n          }\n        }`,\n    });\n\n    return `${item.status === 'draft' ? 'DRAFT ' : ''}` + item.title + ` (${data.User.name})`;\n  },\n};\n```\n\nand we will get our display of:\n\n![Alt Text](https://raw.githubusercontent.com/Noviny/images/master/blog5-5.png)\n\nNow we have the status of a post, its title, and the name of the author, all bundled into the label.\n\nBundling in the author here might be overkill, but if you want to bundle information from a relationship, it's easy to do.\n\n## Using Other Information\n\nFinally, let's have a fun example. Our users have birthdays, and we want to surface this in a warm, friendly way. As such, we've decided to add an emoji right into the label whenever it's a user's birthday - everywhere a label refers to them will show a little party celebration.\n\nFor this we can write a `labelResolver` such as:\n\n```js\nconst User = {\n  fields: {\n    // all our previous user fields\n    dob: {\n      type: CalendarDay,\n      format: 'do MMMM yyyy',\n      dateFrom: '1901-01-01',\n      dateTo: formatISO(new Date(), { representation: 'date' }),\n    },\n  },\n  labelResolver: item => {\n    let currentDay = new Date().toISOString().slice(0, 10);\n    if (item.dob === currentDay) {\n      return `🍰 ${item.name}`;\n    } else {\n      return item.name;\n    }\n  },\n};\n```\n\nAnd now we can see that it's Luke's birthday! Happy birthday Luke!\n\n![Alt Text](https://raw.githubusercontent.com/Noviny/images/master/blog6-6.png)\n\n> Note: this makes the label dynamic, which means it can't be relied upon by other bits of the system as an item's unique identifier. You should be aware of this when making a dynamic label, but if it suits your needs, let the good times roll.\n\n## Enough Labeling for one day\n\nHopefully this gives you a good idea of what labels are for in Keystone (and the ways you can adapt them to your needs when the defaults aren't what you want), as well as good guidance on responsible labeling within the flexibility that Keystone offers.\n"}},"__N_SSG":true}