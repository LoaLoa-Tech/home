{"pageProps":{"markdownPost":{"name":null,"url":null,"content":"<!--[meta]\nsection: guides\ntitle: Philosophy\nsubSection: graphql\norder: 3\n[meta]-->\n\n# GraphQL Philosophy\n\n> **Note:** This is a conceptual introduction to how the Keystone team think about GraphQL APIs (and hence how Keystone's GraphQL API is generated). For more specific API docs, see the [**GraphQL API Introduction**](/docs/guides/intro-to-graphql.md).\n\n## Goals\n\nA good GraphQL API is a combination of the following criteria:\n\n- **Quick prototyping** no matter the client (mobile, desktop, other APIs, etc)\n- Be **obvious**, **consistent**, and **predictable**\n- Is mostly **CRUD-based** with escape hatches for **Custom Operations**\n- Match developer's **domain knowledge**\n- Be **forward compatible** with future unknown use-cases\n- Fully **leverage the _Graph_** of GraphQL through Relationships\n\n## Keystone's schema design\n\nKeystone's auto-generated GraphQL Schema meets these goals by following a pattern with two distinct sets of things:\n\n### Domain objects\n\nModelled with CRUD (_Create, Read, Update, Delete_) operations, this covers the majority of functionality for most applications.\n\nFor example; the `User` type would have `createUser` / `getUser` / `updateUser` / `deleteUser` mutations.\n\n### Custom operations\n\nBecome apparent over time while building applications and adding to the schema.\n\nFor example; an `authenticateUser` / `submitTPSReport` mutation, or a `recentlyActiveUsers` query.\n\n<p align=\"center\">\n  <img src=\"tweet-graphql-2-things.png\" alt=\"Tweet by Jess Telford: In my experience, the best GraphQL APIs have 2 distinct sets of things: 1. Domain Objects are modelled as type with CRUD mutations (`createUser`/`updateUser`/etc). 2. Common actions involving 0 or more Domain Objects are mutations (`sendEmail`/`finalizeTPSReport`)\" width=\"500\" />\n</p>\n\n<sub align=\"center\">\n\n_[Tweet](https://twitter.com/JessTelford/status/1179175687560630272) by [Jess Telford](https://twitter.com/JessTelford)_\n\n</sub>\n\n## Domain objects and CRUD\n\nEvery _thing_ in your application / website / database which can be queried or modified in some way is a Domain Object. Each Domain Object has its own set of CRUD operations.\n\nBy modeling a schema in this way, it enables fast iteration with a consistent and predictable set of mutations and queries for every Domain Object.\n\nTo define a set of Domain Objects, it helps to think about it in terms of what a user will see. A blog site may have a series of Domain Objects, each with their own CRUD operations:\n\n| Domain Object | C               | R            | U               | D               |\n| ------------- | --------------- | ------------ | --------------- | --------------- |\n| **Users**     | `createUser`    | `getUser`    | `updateUser`    | `deleteUser`    |\n| **Posts**     | `createPost`    | `getPost`    | `updatePost`    | `deletePost`    |\n| **Comments**  | `createComment` | `getComment` | `updateComment` | `deleteComment` |\n| **Images**    | `createImage`   | `getImage`   | `updateImage`   | `deleteImage`   |\n\n> **Tip:** Because an `Image` may be uploaded and interacted with independently of a `Post`, or used across multiple posts, we're creating an **Images** list. Even if they're only used in a single `Post`, they still meet the definition as a _thing_ which might be queried or modified in some way (for example, querying for a thumbnail version of the image, or updating alt text).\n\nIn general, Domain Objects map to Lists in Keystone:\n\n```javascript allowCopy=false showLanguage=false\nkeystone.createList('User', {\n  /* ... */\n});\nkeystone.createList('Post', {\n  /* ... */\n});\nkeystone.createList('Comment', {\n  /* ... */\n});\nkeystone.createList('Image', {\n  /* ... */\n});\n```\n\n### Related domain objects\n\nTo fully leverage the _Graph_ of GraphQL, relationships between Domain Objects must be defined in a way that allows for both **querying** and **mutating** related data.\n\nGraphQL gives us _querying_ thanks to their type system:\n\n```graphql\ntype User {\n  name: String\n}\n\ntype Post {\n  title: String\n  author: User\n}\n\ntype Query {\n  getPost(id: ID): Post\n}\n```\n\nHere you can see the `Post.author` field is defined as a relationship to a `User`. When doing a query, it follows a predictable pattern:\n\n```graphql\nquery {\n  getPost(id: \"abc123\") {\n    title\n    author {\n      name\n    }\n  }\n}\n```\n\nDefining _mutations_ requires a bit more setup and consideration to performing _nested mutations_.\n\n> **Hint:** Keystone implements this pattern with the `Relationship` type\n\nNested Mutations are useful when you need to make changes to more than one Domain Object at a time. Just like you may want to query for `Post.author` at the same time as getting `Post.title`, you may want to update `User.name` at the same time as you create a new `Post`.\n\nFor example, imagine a UI where an author could update their bio at the same time as creating a post. The mutation would look something like:\n\n<!-- prettier-ignore-start -->\n\n```graphql\nmutation {\n  createPost(data: {\n    title: \"Hello World\",\n    author: {\n      update: {\n        bio: \"Hi, I'm a writer now!\"\n      }\n    }\n  }) {\n    title\n  }\n}\n```\n\n<!-- prettier-ignore-end -->\n\nNote the `data.author.update` object, this is the _Nested Mutation_. Beyond `update` there are also other operations you may wish to perform:\n\n| Operation    |                                                                                                                           |\n| ------------ | ------------------------------------------------------------------------------------------------------------------------- |\n| `connect`    | Connect an existing item to the parent so future queries for related data return the connected item                       |\n| `disconnect` | Break the connection with an existing item (but do not delete that item) so future queries for related data return `null` |\n| `create`     | Create a new related item and connect it to the parent so future queries for related data return this item                |\n| `update`     | Update an already connected item's data                                                                                   |\n| `delete`     | Delete an already connected item and disconnect it from the parent so future queries for related data return `null`       |\n\n> **Note:** Since `get` is a query concern, and we're only dealing with nested _Mutations_, it is not included here.\n\nThis might be represented in the GraphQL Schema like so:\n\n```graphql\ntype User {\n  name: String\n  bio: String\n}\n\ntype Post {\n  title: String\n  author: User\n}\n\ninput CreateUserInput {\n  name: String\n  bio: String\n}\n\ninput UpdateUserInput {\n  id: ID!\n  name: String\n  bio: String\n}\n\ninput CreatePostInput {\n  title: String\n  author: UserToOneRelationshipInput\n}\n\ninput UpdatePostInput {\n  id: ID!\n  title: String\n  author: UserToOneRelationshipInput\n}\n\ninput UpdateUserToOneRelationship {\n  create: CreateUserInput\n  update: UpdateUserInput\n  delete: ID\n  connect: ID\n  disconnect: ID\n}\n\ntype Mutation {\n  createPost(data: CreatePostInput): Post\n  updatePost(data: UpdatePostInput): Post\n  createUser(data: CreateUserInput): User\n  updateUser(data: UpdateUserInput): User\n}\n```\n\n### Custom operations\n\nCustom operations are an emergent property of the schema design. They are not something which should be defined up front.\n\nAs products are built, it will become obvious which operations are missing and what their inputs/outputs should be.\n\nFor example, while building out the TPS application, it became evident that at some point a TPS Report had to be printed and handed directly to a boss. There is no CRUD operation which can trigger printing a report. There are, however, the _Printing_ and _Courier_ services. A custom mutation can be made which uses both those services to complete the operation: `submitTPSReport`.\n\n```javascript\nconst typeDefs = `\n  type Mutation {\n    submitTPSReport(TPSReportId: String, bossId: String): Boolean\n  }\n`;\n\nconst resolvers = {\n  Mutation: {\n    submitTPSReport: async (_, { TPSReportId, bossId }) => {\n      await printService.printTPSReport(TPSReportId);\n      const address = await getAddress(bossId);\n      await courierService.submitJob({ from: 'printer', to: address });\n      return true;\n    },\n  },\n};\n\nconst server = new ApolloServer({ typeDefs, resolvers });\n```\n"}},"__N_SSG":true}