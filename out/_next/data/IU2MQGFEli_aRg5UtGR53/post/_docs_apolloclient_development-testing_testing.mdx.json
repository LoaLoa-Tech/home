{"pageProps":{"markdownPost":{"name":null,"url":null,"content":"---\ntitle: Testing React components\ndescription: Using MockedProvider and associated APIs\n---\n\nimport {\n  ExpansionPanel,\n} from 'gatsby-theme-apollo-docs/src/components/expansion-panel';\n\nThis article describes best practices for testing React components that use Apollo Client.\n\nThe examples below use [Jest](https://facebook.github.io/jest/docs/en/tutorial-react.html) and React's [test renderer](https://reactjs.org/docs/test-renderer.html) instead of tools like [Enzyme](https://github.com/airbnb/enzyme) or [react-testing-library](https://github.com/kentcdodds/react-testing-library), but the concepts apply to any testing framework.\n\n## The `MockedProvider` component\n\nEvery test for a React component that uses Apollo Client must make Apollo Client available on [React's context](https://reactjs.org/docs/context.html). In application code, you achieve this by wrapping your component tree with the `ApolloProvider` component. In your tests, you use the `MockedProvider` component instead.\n\nThe `MockedProvider` component enables you to define mock responses for individual queries that are executed in your test. This means your test _doesn't_ need to communicate with a GraphQL server, which removes an external dependency and therefore improves the test's reliability.\n\n### Example\n\nLet's say we want to test the following `Dog` component, which executes a basic query and displays its result:\n\n<ExpansionPanel title=\"Click to expand üê∂\">\n\n```jsx:title=dog.jsx\nimport React from 'react';\nimport { gql, useQuery } from '@apollo/client';\n\n// Make sure that both the query and the component are exported\nexport const GET_DOG_QUERY = gql`\n  query GetDog($name: String) {\n    dog(name: $name) {\n      id\n      name\n      breed\n    }\n  }\n`;\n\nexport function Dog({ name }) {\n  const { loading, error, data } = useQuery(\n    GET_DOG_QUERY,\n    { variables: { name } }\n  );\n  if (loading) return <p>Loading...</p>;\n  if (error) return <p>Error!</p>;\n\n  return (\n    <p>\n      {data.dog.name} is a {data.dog.breed}\n    </p>\n  );\n}\n```\n\n</ExpansionPanel>\n\nA basic rendering test for the component looks like this (minus mocked responses):\n\n```jsx:title=dog.test.js\nimport TestRenderer from 'react-test-renderer';\nimport { MockedProvider } from '@apollo/client/testing';\nimport { GET_DOG_QUERY, Dog } from './dog';\n\nconst mocks = []; // We'll fill this in next\n\nit('renders without error', () => {\n  const component = TestRenderer.create(\n    <MockedProvider mocks={mocks} addTypename={false}>\n      <Dog name=\"Buck\" />\n    </MockedProvider>,\n  );\n\n  const tree = component.toJSON();\n  expect(tree.children).toContain('Loading...');\n});\n```\n\n#### Defining mocked responses\n\nThe `mocks` prop of `MockedProvider` is an array of objects, each of which defines the mock response for a single operation. Let's define a mocked response for `GET_DOG_QUERY` when it's passed the `name` `Buck`:\n\n```jsx:title=dog.test.js\nconst mocks = [\n  {\n    request: {\n      query: GET_DOG_QUERY,\n      variables: {\n        name: 'Buck',\n      },\n    },\n    result: {\n      data: {\n        dog: { id: '1', name: 'Buck', breed: 'bulldog' },\n      },\n    },\n  },\n];\n```\n\nEach mock object defines a `request` field (indicating the shape and variables of the operation to match against) and a `result` field (indicating the shape of the response to return for that operation).\n\n> **Your test must execute an operation that _exactly_ matches a mock's shape _and_ variables to receive the associated mocked response.**\n\nAlternatively, the `result` field can be a function that returns a mocked response after performing arbitrary logic:\n\n```jsx\nresult: () => {\n  // ...arbitrary logic...\n\n  return {\n    data: {\n      dog: { id: '1', name: 'Buck', breed: 'bulldog' },\n    },\n  }\n},\n```\n\nCombining our code above, we get the following complete test:\n\n<ExpansionPanel title=\"Click to expand üê∂\">\n\n```jsx:title=dog.test.js\nimport TestRenderer from 'react-test-renderer';\nimport { MockedProvider } from '@apollo/client/testing';\nimport { GET_DOG_QUERY, Dog } from './dog';\n\nconst mocks = [\n  {\n    request: {\n      query: GET_DOG_QUERY,\n      variables: {\n        name: 'Buck',\n      },\n    },\n    result: {\n      data: {\n        dog: { id: '1', name: 'Buck', breed: 'bulldog' },\n      },\n    },\n  },\n];\n\nit('renders without error', () => {\n  const component = TestRenderer.create(\n    <MockedProvider mocks={mocks} addTypename={false}>\n      <Dog name=\"Buck\" />\n    </MockedProvider>,\n  );\n\n  const tree = component.toJSON();\n  expect(tree.children).toContain('Loading...');\n});\n```\n\n</ExpansionPanel>\n\n> **Important:** As it's written, this test checks whether the `Dog` component renders successfully and displays a `Loading...` message. However, it _doesn't_ wait for `MockedProvider` to respond to `GET_DOG_QUERY`. Even when GraphQL operations are mocked, they're `Promise`-based and therefore asynchronous. Because of this, this test always completes while the component is still in its initial [loading state](#testing-the-loading-state).\n>\n> To test a component's rendering _after_ `MockedProvider` responds, see [The \"completed\" state](#testing-the-success-state) and [Error states](#testing-error-states).\n\n### Setting `addTypename`\n\nIn the example above, we set the `addTypename` prop of `MockedProvider` to `false`. This prevents Apollo Client from automatically adding the special `__typename` field to every object it queries for (it does this by default to support data normalization in the cache).\n\nWe _don't_ want to automatically add `__typename` to `GET_DOG_QUERY` in our test, because then it won't match the shape of the query that our mock is expecting.\n\nUnless you explicitly configure your mocks to expect a `__typename` field, always set `addTypename` to `false` in your tests.\n\n## Testing the \"loading\" state\n\nYou can test how your component is rendered while it's still awaiting a query result. In fact, this is a test's default behavior if it doesn't _explicitly_ wait for the `Promise`-based result from `MockedProvider`.\n\n[The example above](#example) shows a test that renders a component in its \"loading\" state without awaiting a result from `MockedProvider`.\n\n## Testing the \"success\" state\n\nTo test how your component is rendered after its query completes, you can `await` a zero-millisecond timeout before performing your checks. This delays the checks until the next \"tick\" of the event loop, which gives `MockedProvider` an opportunity to populate the mocked result:\n\n```jsx\nit('should render dog', async () => {\n  const dogMock = {\n    request: {\n      query: GET_DOG_QUERY,\n      variables: { name: 'Buck' },\n    },\n    result: {\n      data: { dog: { id: 1, name: 'Buck', breed: 'poodle' } },\n    },\n  };\n\n  const component = TestRenderer.create(\n    <MockedProvider mocks={[dogMock]} addTypename={false}>\n      <Dog name=\"Buck\" />\n    </MockedProvider>,\n  );\n\n  await new Promise(resolve => setTimeout(resolve, 0)); // highlight-line\n\n  const p = component.root.findByType('p');\n  expect(p.children.join('')).toContain('Buck is a poodle');\n});\n```\n\nIf your component performs complex calculations or includes delays in its render logic, you can increase the timeout's duration accordingly. You can also use a package like [`wait-for-expect`](https://npm.im/wait-for-expect) to delay until the render has occurred. The risk of using a package like this everywhere is that _every_ test might take up to five seconds to execute (or longer if the default timeout is increased).\n\n## Testing error states\n\nYour component's error states are just as important to test as its success state, if not more so. You can use the `MockedProvider` component to simulate both network errors and GraphQL errors.\n\n* Network errors are errors that occur while your client attempts to communicate with your GraphQL server.\n* GraphQL errors are errors that occur while your GraphQL server attempts to resolve your client's operation.\n\n> Tests for error states require the same zero-millisecond timeout as [tests for the success state](#testing-the-success-state).\n\n### Network errors\n\nTo simulate a network error, you can include an `error` field in your test's mock object, instead of the `result` field:\n\n```jsx\nit('should show error UI', async () => {\n  const dogMock = {\n    request: {\n      query: GET_DOG_QUERY,\n      variables: { name: 'Buck' },\n    },\n    error: new Error('An error occurred'),\n  };\n\n  const component = TestRenderer.create(\n    <MockedProvider mocks={[dogMock]} addTypename={false}>\n      <Dog name=\"Buck\" />\n    </MockedProvider>,\n  );\n\n  await new Promise(resolve => setTimeout(resolve, 0)); // wait for response\n\n  const tree = component.toJSON();\n  expect(tree.children).toContain('An error occurred');\n});\n```\n\nIn this case, when the `Dog` component executes its query, the `MockedProvider` returns the corresponding error. This applies the error state to our `Dog` component, enabling us to verify that the error is handled gracefully.\n\n### GraphQL errors\n\nTo simulate GraphQL errors, you define an `errors` field _inside_ a mock's `result` field. The value of this field is an array of instantiated `GraphQLError` objects:\n\n```js\nconst dogMock = {\n  // ...\n  result: {\n    errors: [new GraphQLError('Error!')],\n  },\n};\n```\n\nBecause GraphQL supports returning partial results when an error occurs, a mock object's `result` can include both `errors` _and_ `data`.\n\n## Testing mutations\n\nYou test components that use `useMutation` similarly to how you test components that use `useQuery`. Just like in your application code, the primary _difference_ is that you need to call the mutation's **mutate function** to actually execute the operation.\n\n### Example\n\nThe following `DeleteButton` component executes the `DELETE_DOG_MUTATION` to delete a dog named `Buck` from our data graph (don't worry, Buck will be fine üê∂):\n\n```jsx:title=delete-dog.jsx\nexport const DELETE_DOG_MUTATION = gql`\n  mutation deleteDog($name: String!) {\n    deleteDog(name: $name) {\n      id\n      name\n      breed\n    }\n  }\n`;\n\nexport function DeleteButton() {\n  const [mutate, { loading, error, data }] = useMutation(DELETE_DOG_MUTATION);\n\n  if (loading) return <p>Loading...</p>;\n  if (error) return <p>Error!</p>;\n  if (data) return <p>Deleted!</p>;\n\n  return (\n    <button onClick={() => mutate({ variables: { name: 'Buck' } })}>\n      Click to Delete Buck\n    </button>\n  );\n}\n```\n\nWe can test the initial rendering of this component just like we [tested our `Dog` component](#example):\n\n```jsx:title=delete-dog.test.js\nimport TestRenderer from 'react-test-renderer';\nimport { MockedProvider } from '@apollo/client/testing';\nimport DeleteButton, { DELETE_DOG_MUTATION } from './delete-dog';\n\nit('should render without error', () => {\n  TestRenderer.create(\n    <MockedProvider mocks={[]}>\n      <DeleteButton />\n    </MockedProvider>,\n  );\n});\n```\n\nIn the test above, `DELETE_DOG_MUTATION` is _not_ executed, because the mutate function is not called.\n\nThe following test _does_ execute the mutation by clicking the button:\n\n```jsx:title=delete-dog.test.js\nit('should render loading state initially', () => {\n  const deleteDog = { name: 'Buck', breed: 'Poodle', id: 1 };\n  const mocks = [\n    {\n      request: {\n        query: DELETE_DOG_MUTATION,\n        variables: { name: 'Buck' },\n      },\n      result: { data: { deleteDog } },\n    },\n  ];\n\n  const component = TestRenderer.create(\n    <MockedProvider mocks={mocks} addTypename={false}>\n      <DeleteButton />\n    </MockedProvider>,\n  );\n\n  // find the button and simulate a click\n  const button = component.root.findByType('button');\n  button.props.onClick(); // fires the mutation\n\n  const tree = component.toJSON();\n  expect(tree.children).toContain('Loading...');\n});\n```\n\nAgain, this example is similar to [the `useQuery`-based component above](#example), but it differs after the rendering is completed. Because this component relies on a button click to fire a mutation, we use the renderer's API to find the button and simulate a click with its `onClick` handler. This fires off the mutation, and the rest of the test runs as expected.\n\n> Other test utilities like [Enzyme](https://github.com/airbnb/enzyme) and [react-testing-library](https://github.com/kentcdodds/react-testing-library) have built-in tools for finding elements and simulating events, but the concept is the same: find the button and simulate a click on it.\n\nTo test for a successful mutation after simulating the click, use a zero-millisecond timeout, as shown in [Testing the \"success\" state](#testing-the-success-state):\n\n<ExpansionPanel title=\"Click to expand üê∂\">\n\n```jsx\nimport TestRenderer from 'react-test-renderer';\nimport { MockedProvider } from '@apollo/client/testing';\nimport DeleteButton, { DELETE_DOG_MUTATION } from './delete-dog';\n\nit('should delete and give visual feedback', async () => {\n  const deleteDog = { name: 'Buck', breed: 'Poodle', id: 1 };\n  const mocks = [\n    {\n      request: {\n        query: DELETE_DOG_MUTATION,\n        variables: { name: 'Buck' },\n      },\n      result: { data: { deleteDog } },\n    },\n  ];\n\n  const component = TestRenderer.create(\n    <MockedProvider mocks={mocks} addTypename={false}>\n      <DeleteButton />\n    </MockedProvider>,\n  );\n\n  // find the button and simulate a click\n  const button = component.root.findByType('button');\n  button.props.onClick(); // fires the mutation\n\n  await new Promise(resolve => setTimeout(resolve, 0)); // wait for response\n\n  const tree = component.toJSON();\n  expect(tree.children).toContain('Deleted!');\n});\n```\n\n</ExpansionPanel>\n\nRemember that the mock's value for `result` can also be a function, so you can perform arbitrary logic (like setting a boolean to indicate that the mutation completed) before returning its result.\n\n[Testing error states](#testing-error-states) for mutations is identical to testing them for queries..\n\n## Testing with the cache\n\nIf your application sets any [cache configuration options](../caching/cache-configuration/#configuration-options) (such as `possibleTypes` or `typePolicies`), you should provide `MockedProvider` with an instance of `InMemoryCache` that sets the exact same options:\n\n```jsx\nconst cache = new InMemoryCache({\n  // ...configuration options...\n})\n\n<MockedProvider mocks={mocks} cache={cache}>\n  <DeleteButton />\n</MockedProvider>,\n```\n\nThe following sample specifies `possibleTypes` and `typePolicies` in its cache configuration, both of which must also be specified in relevant tests to prevent unexpected behavior.\n\n<ExpansionPanel title=\"Click to expand üê∂\">\n\n```jsx\n// \"Dog\" supertype can be of type \"ShibeInu\"\nconst ShibeFragment = gql`\n  fragment ShibeInuFields on Dog {\n    ... on ShibeInu {\n      tail {\n        isCurly\n      }\n    }\n  }\n`;\n\nexport const GET_DOG_QUERY = gql`\n  query GetDog($name: String) {\n    dog(name: $name) {\n      id\n      name\n      breed\n\n      ...ShibeInuFields\n    }\n  }\n\n  ${ShibeFragment}\n`;\n\nexport const cache = new ApolloClient({\n  cache: new InMemoryCache({\n    possibleTypes: {\n      Dog: ['ShibeInu']\n    },\n    // suppose you want you key fields for \"Dog\" to not be simply \"id\"\n    typePolicies: {\n      keyFields: {\n        Dog: ['name', 'breed']\n      }\n    }\n  })\n})\n```\n\n</ExpansionPanel>\n\n## Sandbox example\n\nFor a working example that demonstrates how to test components, check out this project on CodeSandbox:\n\n[![Edit React-Apollo Testing](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/40k7j708n4)\n"}},"__N_SSG":true}