{"pageProps":{"markdownPost":{"name":null,"url":null,"content":"<!--[meta]\nsection: discussions\ntitle: Server-side GraphQL Operations\n[meta]-->\n\n# Server-side GraphQL Operations\n\nKeystone provides a GraphQL API which we generally think of as being an API that is accessed over HTTP from a client talking to a server.\nThere are many uses cases however where we want to execute GraphQL operations directly on the server.\nThese can be grouped into two main categories:\n\nAs part of a resolver, e.g.\n\n- Hooks\n- Access control\n- Virtual field resolver\n- Custom field type resolvers\n- Custom query/mutation resolvers\n\nAs part of some other process, e.g.\n\n- Migrations\n- Data seeding\n- Responding to a non-GraphQL HTTP request\n- Testing\n- Anything else a developer could possibly imagine\n\nKeystone provides an API which give you complete control over how you execute server-side GraphQL operations in each of these situations.\n\n## Background\n\nThere are four main things that go into executing a server-side GraphQL operation:\n\n- A GraphQL schema\n- The query string\n- Variable values\n- A `context` object\n\nWhen executing queries over HTTP we only have control over the queries and variables.\nOn the server side we can also control the schema and the `context`.\n\nIn most Keystone systems there will only be a single schema, but it is possible to configure multiple schemas (although this is not well documented).\n\nThe [`context` object](https://www.apollographql.com/docs/apollo-server/data/resolvers/#the-context-argument) is a general purpose object which is made available to all resolvers. When performing HTTP queries this object is built by Apollo server based on the `request` object. When directly performing server-side operations we need to be able to create our own `context` object.\n\n## Within Resolvers\n\nWhile Keystone generates the basic CRUD resolvers for you, there are lots of ways you can write custom code which is executed during the resolver phase of a query.\nThese include:\n\n- Hooks\n- Access control\n- Virtual field resolver\n- Custom field type resolvers\n- Custom query/mutation resolvers\n\nThe [signature of a resolver function](https://www.apollographql.com/docs/apollo-server/data/resolvers/#resolver-arguments) is `(parent, args, context, info)`.\nThe `context` argument is an object which is provided to all resolvers and can contain and state or functions which should be shared across all resolvers.\nThe `context` object is also passed through to all hooks and access control functions.\n\nAs a developer you might want to execute some GraphQL operations as part of your custom code.\nThis can be done using the function `context.executeGraphQL()`, which is added to the `context` object by Keystone.\nThis async function takes a `query` and `variables` as arguments and returns `{ data, errors }` as a response.\n\n```javascript\nconst { gql } = require('apollo-server-express');\n\nconst { data, errors } = await context.executeGraphQL({\n  query: gql` ... `,\n  variables: { ... },\n});\n```\n\n### Custom context\n\nThe function `context.executeGraphQL` will pass `context` through to the resolvers used in the operation.\nThere are some instances where you may wish to use a different context to perform the operation.\nFor example, you might wish to execute your operation with all access-control turned off, or authenticated as a different user.\n\nThis can be achieved using the function `context.createContext({ schemaName, authentication, skipAccessControl })`, which will create a new `context` object based on the supplied arguments.\n\n- `schemaName`: This can be used to select the named schema if you have multiple schemas within your Keystone system.\n- `authentication`: This is an object of the shape `{ item: { id }, listKey: '...' }` which is passed through to access control functions. This can be used to emulate executing the operations as a different user.\n- `skipAccessControl`: This can be used to bypass all access control.\n\nBy default each of these values will take the value of the original `context` object.\nYou can use this functions like this:\n\n```javascript\nconst { gql } = require('apollo-server-express');\n\nconst { data, errors } = await context.executeGraphQL({\n  context: context.createContext({ ... }),\n  query: gql` ... `,\n  variables: { ... },\n});\n```\n\n## General purpose operations\n\nThere are situations where you might want to execute a GraphQL operations outside of the context of a resolver function.\nThese include:\n\n- Migrations\n- Data seeding\n- Responding to a non-GraphQL HTTP request\n- Testing\n- Anything else a developer could possibly imagine\n\nIn these cases there is no `context` object for you to borrow, but there is an API to create one for use.\n\nThe methods `keystone.createContext()` and `keystone.executeGraphQL()` behave almost exactly the same as the functions `context.createContext()` and `context.executeGraphQL()` respectively. There a few key differences\n\n1. If you do not supply a `context` to `keystone.executeGraphQL()` it will create one using the default arguments to `keystone.createContext()`.\n2. The default arguments for `context.createContext()` are `{ schemaName = 'public', authentication = {}, skipAccessControl = false}`. This is because there is no originating `context` object to borrow the defaults from.\n\nThese methods can be used anywhere you have access to the keystone object.\n\n```javascript\nconst { gql } = require('apollo-server-express');\n\nconst { data, errors } = await keystone.executeGraphQL({\n  context: keystone.createContext({ ... }),\n  query: gql` ... `,\n  variables: { ... },\n});\n```\n"}},"__N_SSG":true}