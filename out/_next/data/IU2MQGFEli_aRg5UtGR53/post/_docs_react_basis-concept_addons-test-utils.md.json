{"pageProps":{"markdownPost":{"name":null,"url":null,"content":"---\nid: test-utils\ntitle: Test Utilities\npermalink: docs/test-utils.html\nlayout: docs\ncategory: Reference\n---\n\n**Importing**\n\n```javascript\nimport ReactTestUtils from 'react-dom/test-utils'; // ES6\nvar ReactTestUtils = require('react-dom/test-utils'); // ES5 with npm\n```\n\n## Overview {#overview}\n\n`ReactTestUtils` makes it easy to test React components in the testing framework of your choice. At Facebook we use [Jest](https://facebook.github.io/jest/) for painless JavaScript testing. Learn how to get started with Jest through the Jest website's [React Tutorial](https://jestjs.io/docs/tutorial-react).\n\n> Note:\n>\n> We recommend using [React Testing Library](https://testing-library.com/react) which is designed to enable and encourage writing tests that use your components as the end users do.\n>\n> Alternatively, Airbnb has released a testing utility called [Enzyme](https://airbnb.io/enzyme/), which makes it easy to assert, manipulate, and traverse your React Components' output.\n\n - [`act()`](#act)\n - [`mockComponent()`](#mockcomponent)\n - [`isElement()`](#iselement)\n - [`isElementOfType()`](#iselementoftype)\n - [`isDOMComponent()`](#isdomcomponent)\n - [`isCompositeComponent()`](#iscompositecomponent)\n - [`isCompositeComponentWithType()`](#iscompositecomponentwithtype)\n - [`findAllInRenderedTree()`](#findallinrenderedtree)\n - [`scryRenderedDOMComponentsWithClass()`](#scryrendereddomcomponentswithclass)\n - [`findRenderedDOMComponentWithClass()`](#findrendereddomcomponentwithclass)\n - [`scryRenderedDOMComponentsWithTag()`](#scryrendereddomcomponentswithtag)\n - [`findRenderedDOMComponentWithTag()`](#findrendereddomcomponentwithtag)\n - [`scryRenderedComponentsWithType()`](#scryrenderedcomponentswithtype)\n - [`findRenderedComponentWithType()`](#findrenderedcomponentwithtype)\n - [`renderIntoDocument()`](#renderintodocument)\n - [`Simulate`](#simulate)\n\n## Reference {#reference}\n\n### `act()` {#act}\n\nTo prepare a component for assertions, wrap the code rendering it and performing updates inside an `act()` call. This makes your test run closer to how React works in the browser.\n\n>Note\n>\n>If you use `react-test-renderer`, it also provides an `act` export that behaves the same way.\n\nFor example, let's say we have this `Counter` component:\n\n```js\nclass Counter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {count: 0};\n    this.handleClick = this.handleClick.bind(this);\n  }\n  componentDidMount() {\n    document.title = `You clicked ${this.state.count} times`;\n  }\n  componentDidUpdate() {\n    document.title = `You clicked ${this.state.count} times`;\n  }\n  handleClick() {\n    this.setState(state => ({\n      count: state.count + 1,\n    }));\n  }\n  render() {\n    return (\n      <div>\n        <p>You clicked {this.state.count} times</p>\n        <button onClick={this.handleClick}>\n          Click me\n        </button>\n      </div>\n    );\n  }\n}\n```\n\nHere is how we can test it:\n\n```js{3,20-22,29-31}\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { act } from 'react-dom/test-utils';\nimport Counter from './Counter';\n\nlet container;\n\nbeforeEach(() => {\n  container = document.createElement('div');\n  document.body.appendChild(container);\n});\n\nafterEach(() => {\n  document.body.removeChild(container);\n  container = null;\n});\n\nit('can render and update a counter', () => {\n  // Test first render and componentDidMount\n  act(() => {\n    ReactDOM.render(<Counter />, container);\n  });\n  const button = container.querySelector('button');\n  const label = container.querySelector('p');\n  expect(label.textContent).toBe('You clicked 0 times');\n  expect(document.title).toBe('You clicked 0 times');\n\n  // Test second render and componentDidUpdate\n  act(() => {\n    button.dispatchEvent(new MouseEvent('click', {bubbles: true}));\n  });\n  expect(label.textContent).toBe('You clicked 1 times');\n  expect(document.title).toBe('You clicked 1 times');\n});\n```\n\n- Don't forget that dispatching DOM events only works when the DOM container is added to the `document`. You can use a library like [React Testing Library](https://testing-library.com/react) to reduce the boilerplate code.\n\n- The [`recipes`](/docs/testing-recipes.html) document contains more details on how `act()` behaves, with examples and usage.\n\n* * *\n\n### `mockComponent()` {#mockcomponent}\n\n```javascript\nmockComponent(\n  componentClass,\n  [mockTagName]\n)\n```\n\nPass a mocked component module to this method to augment it with useful methods that allow it to be used as a dummy React component. Instead of rendering as usual, the component will become a simple `<div>` (or other tag if `mockTagName` is provided) containing any provided children.\n\n> Note:\n>\n> `mockComponent()` is a legacy API. We recommend using [`jest.mock()`](https://facebook.github.io/jest/docs/en/tutorial-react-native.html#mock-native-modules-using-jestmock) instead.\n\n* * *\n\n### `isElement()` {#iselement}\n\n```javascript\nisElement(element)\n```\n\nReturns `true` if `element` is any React element.\n\n* * *\n\n### `isElementOfType()` {#iselementoftype}\n\n```javascript\nisElementOfType(\n  element,\n  componentClass\n)\n```\n\nReturns `true` if `element` is a React element whose type is of a React `componentClass`.\n\n* * *\n\n### `isDOMComponent()` {#isdomcomponent}\n\n```javascript\nisDOMComponent(instance)\n```\n\nReturns `true` if `instance` is a DOM component (such as a `<div>` or `<span>`).\n\n* * *\n\n### `isCompositeComponent()` {#iscompositecomponent}\n\n```javascript\nisCompositeComponent(instance)\n```\n\nReturns `true` if `instance` is a user-defined component, such as a class or a function.\n\n* * *\n\n### `isCompositeComponentWithType()` {#iscompositecomponentwithtype}\n\n```javascript\nisCompositeComponentWithType(\n  instance,\n  componentClass\n)\n```\n\nReturns `true` if `instance` is a component whose type is of a React `componentClass`.\n\n* * *\n\n### `findAllInRenderedTree()` {#findallinrenderedtree}\n\n```javascript\nfindAllInRenderedTree(\n  tree,\n  test\n)\n```\n\nTraverse all components in `tree` and accumulate all components where `test(component)` is `true`. This is not that useful on its own, but it's used as a primitive for other test utils.\n\n* * *\n\n### `scryRenderedDOMComponentsWithClass()` {#scryrendereddomcomponentswithclass}\n\n```javascript\nscryRenderedDOMComponentsWithClass(\n  tree,\n  className\n)\n```\n\nFinds all DOM elements of components in the rendered tree that are DOM components with the class name matching `className`.\n\n* * *\n\n### `findRenderedDOMComponentWithClass()` {#findrendereddomcomponentwithclass}\n\n```javascript\nfindRenderedDOMComponentWithClass(\n  tree,\n  className\n)\n```\n\nLike [`scryRenderedDOMComponentsWithClass()`](#scryrendereddomcomponentswithclass) but expects there to be one result, and returns that one result, or throws exception if there is any other number of matches besides one.\n\n* * *\n\n### `scryRenderedDOMComponentsWithTag()` {#scryrendereddomcomponentswithtag}\n\n```javascript\nscryRenderedDOMComponentsWithTag(\n  tree,\n  tagName\n)\n```\n\nFinds all DOM elements of components in the rendered tree that are DOM components with the tag name matching `tagName`.\n\n* * *\n\n### `findRenderedDOMComponentWithTag()` {#findrendereddomcomponentwithtag}\n\n```javascript\nfindRenderedDOMComponentWithTag(\n  tree,\n  tagName\n)\n```\n\nLike [`scryRenderedDOMComponentsWithTag()`](#scryrendereddomcomponentswithtag) but expects there to be one result, and returns that one result, or throws exception if there is any other number of matches besides one.\n\n* * *\n\n### `scryRenderedComponentsWithType()` {#scryrenderedcomponentswithtype}\n\n```javascript\nscryRenderedComponentsWithType(\n  tree,\n  componentClass\n)\n```\n\nFinds all instances of components with type equal to `componentClass`.\n\n* * *\n\n### `findRenderedComponentWithType()` {#findrenderedcomponentwithtype}\n\n```javascript\nfindRenderedComponentWithType(\n  tree,\n  componentClass\n)\n```\n\nSame as [`scryRenderedComponentsWithType()`](#scryrenderedcomponentswithtype) but expects there to be one result and returns that one result, or throws exception if there is any other number of matches besides one.\n\n***\n\n### `renderIntoDocument()` {#renderintodocument}\n\n```javascript\nrenderIntoDocument(element)\n```\n\nRender a React element into a detached DOM node in the document. **This function requires a DOM.** It is effectively equivalent to:\n\n```js\nconst domContainer = document.createElement('div');\nReactDOM.render(element, domContainer);\n```\n\n> Note:\n>\n> You will need to have `window`, `window.document` and `window.document.createElement` globally available **before** you import `React`. Otherwise React will think it can't access the DOM and methods like `setState` won't work.\n\n* * *\n\n## Other Utilities {#other-utilities}\n\n### `Simulate` {#simulate}\n\n```javascript\nSimulate.{eventName}(\n  element,\n  [eventData]\n)\n```\n\nSimulate an event dispatch on a DOM node with optional `eventData` event data.\n\n`Simulate` has a method for [every event that React understands](/docs/events.html#supported-events).\n\n**Clicking an element**\n\n```javascript\n// <button ref={(node) => this.button = node}>...</button>\nconst node = this.button;\nReactTestUtils.Simulate.click(node);\n```\n\n**Changing the value of an input field and then pressing ENTER.**\n\n```javascript\n// <input ref={(node) => this.textInput = node} />\nconst node = this.textInput;\nnode.value = 'giraffe';\nReactTestUtils.Simulate.change(node);\nReactTestUtils.Simulate.keyDown(node, {key: \"Enter\", keyCode: 13, which: 13});\n```\n\n> Note\n>\n> You will have to provide any event property that you're using in your component (e.g. keyCode, which, etc...) as React is not creating any of these for you.\n\n* * *\n"}},"__N_SSG":true}