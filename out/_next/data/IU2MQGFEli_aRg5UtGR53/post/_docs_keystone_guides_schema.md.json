{"pageProps":{"markdownPost":{"name":null,"url":null,"content":"<!--[meta]\nsection: guides\ntitle: Data modelling\n[meta]-->\n\n# Data modelling\n\nA schema definition (_often abbreviated to \"schema\"_) is defined by:\n\n- a set of **Lists**\n- containing one or more **Fields**\n- which each have a **Type**\n\n<!-- TODO: Link to glossary -->\n\n<!-- TODO: Make this a component that can be imported somehow -->\n\n```javascript\nkeystone.createList('Todo', {\n  fields: {\n    task: { type: Text },\n  },\n});\n```\n\n> Create a **List** called `Todo`, containing a single **Field** `task`, with a **Type** of `Text`\n\n## Lists\n\nYou can create as many lists as your project needs:\n\n```javascript\nkeystone.createList('Todo', {\n  fields: {\n    task: { type: Text },\n  },\n});\n\nkeystone.createList('User', {\n  fields: {\n    name: { type: Text },\n    email: { type: Text },\n  },\n});\n```\n\nAnd each list can have as many fields as you need.\n\nKeystone will process each List, converting it into a series of GraphQL CRUD\n(**C**reate, **R**ead, **U**pdate, **D**elete) operations. For example, the above lists will generate:\n\n```graphql\ntype Mutation {\n  createTodo(...): Todo\n  updateTodo(...): Todo\n  deleteTodo(...): Todo\n  createUser(...): User\n  updateUser(...): User\n  deleteUser(...): User\n}\n\ntype Query {\n  allTodos(...): [Todo]\n  Todo(...): Todo\n  allUsers(...): [User]\n  User(...): User\n}\n\ntype Todo {\n  id: ID\n  task: String\n}\n\ntype User {\n  id: ID\n  name: String\n  email: String\n}\n```\n\n> **Note:** Only a subset of the generated types/mutations/queries are shown here.\n> For more details, see the [GraphQL introduction guide](/docs/guides/intro-to-graphql.md).\n\n### Customising lists and fields\n\nBoth lists and fields can accept further options:\n\n```javascript\nkeystone.createList('Todo', {\n  fields: {\n    task: { type: Text, isRequired: true },\n  },\n  adminConfig: {\n    defaultPageSize: 20,\n  },\n});\n```\n\nIn this example, the `adminConfig` options will apply only to the `Todo` list\n(setting how many items are shown per page in the [Admin UI](/packages/app-admin-ui/README.md)).\nThe `isRequired` option will ensure an API error\nis thrown if a `task` value is not provided when creating/updating items.\n\n<!-- TODO: Screenshot -->\n\n_For more List options, see the [`createList()` API docs](/docs/api/create-list.md)._\n\n_[There are many different field types available](/packages/fields/README.md),\neach specifying their own options._\n\n### Related lists\n\nOne of Keystone' most powerful features is defining **Relationships** between\nLists.\n\nRelationships are a special field type in Keystone used to generate rich\nGraphQL operations and an intuitive Admin UI, especially useful for complex\ndata modeling requirements.\n\n#### Why relationships?\n\n_Already know Relationships? [Skip to **Defining Relationships** below](#defining-relationships)._\n\nTo understand the power of Relationships, let's imagine a world without them:\n\n```javascript\nkeystone.createList('Todo', {\n  fields: {\n    task: { type: Text, isRequired: true },\n    createdBy: { type: Text },\n  },\n});\n```\n\nIn this example, every todo has a user it belongs to (the `createdBy` field). We\ncan query for all todos owned by a particular user, update the user, etc.\n\nLet's imagine we have a single item in our `Todo` list:\n\n| `id` | `task`       | `createdBy` |\n| ---- | ------------ | ----------- |\n| 1    | Use Keystone | Tici        |\n\nWe could query this data like so:\n\n```graphql\nquery {\n  allTodos {\n    task\n    createdBy\n  }\n}\n\n# output:\n# {\n#   allTodos: [\n#     { task: 'Use Keystone', createdBy: 'Tici' }\n#   ]\n# }\n```\n\nEverything looks great so far. Now, let's add another task:\n\n##### Todo\n\n| `id` | `task`       | `createdBy` |\n| ---- | ------------ | ----------- |\n| 1    | Use Keystone | Tici        |\n| 2    | Setup linter | Tici        |\n\n```graphql\nquery {\n  allTodos {\n    task\n    createdBy\n  }\n}\n\n# output:\n# {\n#   allTodos: [\n#     { task: 'Use Keystone', createdBy: 'Tici' }\n#     { task: 'Setup linter', createdBy: 'Tici' }\n#   ]\n# }\n```\n\nStill ok.\n\nWhat if we add a new field:\n\n```javascript\nkeystone.createList('Todo', {\n  fields: {\n    task: { type: Text, isRequired: true },\n    createdBy: { type: Text },\n    email: { type: Text },\n  },\n});\n```\n\n##### Todo\n\n| `id` | `task`       | `createdBy` | `email`          |\n| ---- | ------------ | ----------- | ---------------- |\n| 1    | Use Keystone | Tici        | tici@example.com |\n| 2    | Setup Linter | Tici        | tici@example.com |\n\n```graphql\nquery {\n  allTodos {\n    task\n    createdBy\n    email\n  }\n}\n\n# output:\n# {\n#   allTodos: [\n#     { task: 'Use Keystone', createdBy: 'Tici', email: 'tici@example.com' }\n#     { task: 'Setup linter', createdBy: 'Tici', email: 'tici@example.com' }\n#   ]\n# }\n```\n\nNow we're starting to see multiple sets of duplicated data (`createdBy` +\n`email` are repeated). If we wanted to update the `email` field, we'd have to\nfind all items, change the value, and save it back. Not so bad with 2 items, but\nwhat about 300? 10,000? It can be quite a big operation to make these changes.\n\nWe can avoid the duplicate data by moving it out into its own `User` list:\n\n##### Todo\n\n| `id` | `task`       | `createdBy` |\n| ---- | ------------ | ----------- |\n| 1    | Use Keystone | 1           |\n| 2    | Setup Linter | 1           |\n\n##### User\n\n| `id` | `name` | `email`          |\n| ---- | ------ | ---------------- |\n| 1    | Tici   | tici@example.com |\n\nThe `createdBy` field is no longer a name, but instead refers to the `id` of an\nitem in the `User` list (commonly referred to as _[data\nnormalization](https://en.wikipedia.org/wiki/Database_normalization)_).\n\nThis gives us only one place to update `email`.\n\nNow that we have two different lists, to get all the data now takes two queries:\n\n```graphql\nquery {\n  allTodos {\n    task\n    createdBy\n  }\n}\n\n# output:\n# {\n#   allTodos: [\n#     { task: 'Use Keystone', createdBy: 1 }\n#     { task: 'Setup linter', createdBy: 1 }\n#   ]\n# }\n```\n\nWe'd then have to iterate over each item and extract the `createdBy` id, to be\npassed to a query such as:\n\n```graphql\nquery {\n  User(where: { id: \"1\" }) {\n    name\n    email\n  }\n}\n\n# output:\n# {\n#   User: { name: 'Tici', email: 'tici@example.com' }\n# }\n```\n\nWhich we'd have to execute once for every `User` that was referenced by a\n`Todo`'s `createdBy` field.\n\nUsing **Relationships** makes this a lot easier.\n\n#### Defining Relationships\n\nRelationships are defined using the `Relationship` field type, and require at\nleast 2 configured lists (one will refer to the other).\n\n```javascript\nconst { Relationship } = require('@keystonejs/fields');\n\nkeystone.createList('Todo', {\n  fields: {\n    task: { type: Text },\n    createdBy: { type: Relationship, ref: 'User' },\n  },\n});\n\nkeystone.createList('User', {\n  fields: {\n    name: { type: Text },\n    email: { type: Text },\n  },\n});\n```\n\nThis is a [to-single relationship](#to-single-relationships) from the `Todo`\nlist to an item in the `User` list.\n\nTo query the data, we can write a single query which returns both the `Todo`s\nand their related `User`s:\n\n```graphql\nquery {\n  allTodos {\n    task\n    createdBy {\n      name\n      email\n    }\n  }\n}\n\n# output:\n# {\n#   allTodos: [\n#     { task: 'Use Keystone', createdBy: { name: 'Tici', email: 'tici@example.com' } }\n#     { task: 'Setup linter', createdBy: { name: 'Tici', email: 'tici@example.com' } }\n#   ]\n# }\n```\n\nA note on definitions:\n\n- **To-single / To-many** refer to _the number of related items_ (1, or more than 1).\n- **One-way / Two-way** refer to _the direction of the query_.\n- **Back References** refer to a special type of two-way relationships where _one\n  field can update a related list's field as it changes_.\n\n#### To-single Relationships\n\nWhen you have a single related item you want to refer to, a _to-single_\nrelationship allows storing that item, and querying it via the GraphQL API.\n\n```javascript\nkeystone.createList('Todo', {\n  fields: {\n    task: { type: Text },\n    createdBy: { type: Relationship, ref: 'User' },\n  },\n});\n\nkeystone.createList('User', {\n  fields: {\n    name: { type: Text },\n    email: { type: Text },\n  },\n});\n```\n\nHere we've defined the `createdBy` field to be a `Relationship` type, and\nconfigured its relation to be the `User` list by setting the `ref` option.\n\nA query for a to-single relationship field will return an object with the\nrequested data:\n\n```graphql\nquery {\n  Todo(where: { id: \"<todoId>\" }) {\n    createdBy {\n      id\n      name\n    }\n  }\n}\n\n# output:\n# {\n#   Todo: {\n#     createdBy: { id: '1', name: 'Tici' }\n#   }\n# }\n```\n\nThe data stored in the database for the `createdBy` field will be a single ID:\n\n##### Todo\n\n| `id` | `task`       | `createdBy` |\n| ---- | ------------ | ----------- |\n| 1    | Use Keystone | 1           |\n| 2    | Setup Linter | 1           |\n\n##### User\n\n| `id` | `name` | `email`          |\n| ---- | ------ | ---------------- |\n| 1    | Tici   | tici@example.com |\n\n#### To-many Relationships\n\nWhen you have multiple items you want to refer to from a single field, a\n_to-many_ relationship will store an array, also exposing that array via the\nGraphQL API.\n\n```javascript\nkeystone.createList('Todo', {\n  fields: {\n    task: { type: Text },\n  },\n});\n\nkeystone.createList('User', {\n  fields: {\n    name: { type: Text },\n    email: { type: Text },\n    todoList: { type: Relationship, ref: 'Todo', many: true },\n  },\n});\n```\n\nA query for a to-many relationship field will return an array of objects with\nthe requested data:\n\n```graphql\nquery {\n  User(where: { id: \"<userId>\" }) {\n    todoList {\n      task\n    }\n  }\n}\n\n# output:\n# {\n#   User: {\n#     todoList: [\n#       { task: 'Use Keystone' },\n#       { task: 'Setup linter' },\n#     ]\n#   ]\n# }\n```\n\nThe data stored in the database for the `todoList` field will be an array of\nIDs:\n\n##### Todo\n\n| `id` | `task`       |\n| ---- | ------------ |\n| 1    | Use Keystone |\n| 2    | Setup Linter |\n| 3    | Be Awesome   |\n| 4    | Write docs   |\n| 5    | Buy milk     |\n\n##### User\n\n| `id` | `name` | `email`          | `todoList` |\n| ---- | ------ | ---------------- | ---------- |\n| 1    | Tici   | tici@example.com | [1, 2]     |\n| 2    | Jess   | jess@example.com | [3, 4, 5]  |\n\n#### Two-way Relationships\n\nIn the [to-single](#to-single-relationships) and\n[to-many](#to-many-relationships) examples above, we were only querying _in one\ndirection_; always from the list with the Relationship field.\n\nOften, you will want to query _in both directions_ (aka _two-way_). For example:\nyou may want to list all Todo tasks for a User _and_ want to list the User who\nowns a Todo.\n\nA two-way relationship requires having a `Relationship` field on both lists:\n\n```javascript\nkeystone.createList('Todo', {\n  fields: {\n    task: { type: Text },\n    createdBy: { type: Relationship, ref: 'User' },\n  },\n});\n\nkeystone.createList('User', {\n  fields: {\n    name: { type: Text },\n    email: { type: Text },\n    todoList { type: Relationship, ref: 'Todo', many: true },\n  }\n});\n```\n\nHere we have two relationships:\n\n- A _to-single_ `createdBy` field on the `Todo` list, and\n- A _to-many_ `todoList` field on the `User` list.\n\nNow it's possible to query in both directions:\n\n```graphql\nquery {\n  User(where: { id: \"<userId>\" }) {\n    todoList {\n      task\n    }\n  }\n\n  Todo(where: { id: \"<todoId>\" }) {\n    createdBy {\n      id\n      name\n    }\n  }\n}\n\n# output:\n# {\n#   User: {\n#     todoList: [\n#       { task: 'Use Keystone' },\n#       { task: 'Setup linter' },\n#     ]\n#   ],\n#   Todo: {\n#     createdBy: { id: '1', name: 'Tici' }\n#   }\n# }\n```\n\nThe database would look like:\n\n##### Todo\n\n| `id` | `task`       | `createdBy` |\n| ---- | ------------ | ----------- |\n| 1    | Use Keystone | 1           |\n| 2    | Setup Linter | 1           |\n| 3    | Be Awesome   | 2           |\n| 4    | Write docs   | 2           |\n| 5    | Buy milk     | 2           |\n\n##### User\n\n| `id` | `name` | `email`          | `todoList` |\n| ---- | ------ | ---------------- | ---------- |\n| 1    | Tici   | tici@example.com | [1, 2]     |\n| 2    | Jess   | jess@example.com | [3, 4, 5]  |\n\nNote the two relationship fields in this example _know nothing about each other_.\nThey are not specially linked. This means if you update data in one place, you\nmust update it in both. To automate this and link two relationship fields, read\non about `Relationship Back References` below.\n\n#### Relationship Back References\n\nThere is a special type of [two-way relationship](#two-way-relationships) where\n_one field can update a related list's field as it changes_. The mechanism\nenabling this is called _Back References_.\n\n```javascript\nkeystone.createList('Todo', {\n  fields: {\n    task: { type: Text },\n    createdBy: { type: Relationship, ref: 'User' },\n  },\n});\n\nkeystone.createList('User', {\n  fields: {\n    name: { type: Text },\n    email: { type: Text },\n    todoList { type: Relationship, ref: 'Todo', many: true },\n  }\n});\n```\n\nIn this example, when a new `Todo` item is created, we can set the `createdBy`\nfield as part of the mutation:\n\n```graphql\nmutation {\n  createTodo(data: {\n    task: 'Learn Node',\n    createdBy: { connect: { id: '1' } },\n  }) {\n    id\n  }\n}\n```\n\n_See [the Relationship API docs for more on `connect`](/packages/fields/src/types/Relationship/README.md)._\n\nIf this was the first `Todo` item created, the database would now look like:\n\n##### Todo\n\n| `id` | `task`     | `createdBy` |\n| ---- | ---------- | ----------- |\n| 1    | Learn Node | 1           |\n\n##### User\n\n| `id` | `name` | `email`          | `todoList` |\n| ---- | ------ | ---------------- | ---------- |\n| 1    | Tici   | tici@example.com | \\[]        |\n\nNotice the `Todo` item's `createdBy` field is set, but the `User` item's\n`todoList` does _not_ contain the ID of the newly created `Todo`!\n\nIf we were to query the data now, we would get:\n\n```graphql\nquery {\n  User(where: { id: \"1\" }) {\n    todoList {\n      id\n      task\n    }\n  }\n\n  Todo(where: { id: \"1\" }) {\n    createdBy {\n      id\n      name\n    }\n  }\n}\n\n# output:\n# {\n#   User: {\n#     todoList: []\n#   ],\n#   Todo: {\n#     createdBy: { id: '1', name: 'Tici' }\n#   }\n# }\n```\n\n_Back References_ solve this problem.\n\nTo setup a back reference, we need to specify both the list _and the field_ in\nthe `ref` option:\n\n```javascript\nkeystone.createList('Todo', {\n  fields: {\n    task: { type: Text },\n    // The `ref` option now includes which field to update\n    createdBy: { type: Relationship, ref: 'User.todoList' },\n  },\n});\n\nkeystone.createList('User', {\n  fields: {\n    name: { type: Text },\n    email: { type: Text },\n    todoList: { type: Relationship, ref: 'Todo', many: true },\n  },\n});\n```\n\nThis works for both [to-single](#to-single-relationships) and\n[to-many](#to-many-relationships) relationships.\n\nNow, if we run the same mutation:\n\n```graphql\nmutation {\n  createTodo(data: {\n    task: 'Learn Node',\n    createdBy: { connect: { id: '1' } },\n  }) {\n    id\n  }\n}\n```\n\nOur database would look like:\n\n##### Todo\n\n| `id` | `task`     | `createdBy` |\n| ---- | ---------- | ----------- |\n| 1    | Learn Node | 1           |\n\n##### User\n\n| `id` | `name` | `email`          | `todoList` |\n| ---- | ------ | ---------------- | ---------- |\n| 1    | Tici   | tici@example.com | [1]        |\n\n```graphql\nquery {\n  User(where: { id: \"1\" }) {\n    todoList {\n      id\n      task\n    }\n  }\n\n  Todo(where: { id: \"1\" }) {\n    createdBy {\n      id\n      name\n    }\n  }\n}\n\n# output:\n# {\n#   User: {\n#     todoList: [{ id: '1', task: 'Learn Node' }]\n#   ],\n#   Todo: {\n#     createdBy: { id: '1', name: 'Tici' }\n#   }\n# }\n```\n\nWe can do the same modification for the `User` list, and reap the same rewards\nfor creating a new `User`:\n\n```javascript\nkeystone.createList('Todo', {\n  fields: {\n    task: { type: Text },\n    // The `ref` option now includes which field to update\n    createdBy: { type: Relationship, ref: 'User.todoList' },\n  }\n});\n\nkeystone.createList('User', {\n  fields: {\n    name: { type: Text },\n    email: { type: Text },\n    todoList { type: Relationship, ref: 'Todo.createdBy', many: true },\n  }\n});\n```\n\nIn this case, we'll create the first task along with creating the user. _For\nmore info on the `create` syntax, see\n[the Relationship API docs](/packages/fields/src/types/Relationship/README.md)._\n\n```graphql\nmutation {\n  createUser(data: {\n    name: 'Tici',\n    email: 'tici@example.com',\n    todoList: { create: [{ task: 'Learn Node' }] },\n  }) {\n    id\n  }\n}\n```\n\nThe data would finally look like:\n\n##### Todo\n\n| `id` | `task`     | `createdBy` |\n| ---- | ---------- | ----------- |\n| 1    | Learn Node | 1           |\n\n##### User\n\n| `id` | `name` | `email`          | `todoList` |\n| ---- | ------ | ---------------- | ---------- |\n| 1    | Tici   | tici@example.com | [1]        |\n"}},"__N_SSG":true}