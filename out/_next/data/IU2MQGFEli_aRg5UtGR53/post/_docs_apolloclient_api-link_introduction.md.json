{"pageProps":{"markdownPost":{"name":null,"url":null,"content":"---\ntitle: Apollo Link overview\ndescription: Customize Apollo Client's data flow\n---\n\n> If your application only needs to send conventional HTTP-based requests to a GraphQL server, you probably don't need to use the Apollo Link API. To learn more, see [Basic HTTP networking](../../networking/basic-http-networking/).\n\nThe **Apollo Link** library helps you customize the flow of data between Apollo Client and your GraphQL server. You can define your client's network behavior as a list of **link** objects that execute in a sequence:\n\n![Visualization of link interaction](../../assets/link/concepts-intro-2.png)\n\n In the above diagram:\n\n 1. The first link might log the details of the operation for debugging purposes.\n 2. The second link might add an HTTP header to the outgoing operation request.\n 3. The third link might then _send_ the request to a GraphQL server over HTTP.\n\n Note that although the figure above shows the rightmost link requesting results from a remote server, it can execute GraphQL operations against any local or remote target that can respond to them.\n\nBy default, Apollo Client uses Apollo Link's `HttpLink` to send GraphQL operations to a remote server over HTTP. Apollo Client takes care of creating this default link, and it covers many use cases without requiring additional customization.\n\nTo extend or replace Apollo Client's default networking layer, you can define one or more _custom_ links and specify their order of execution in the `ApolloClient` constructor.\n\n## The anatomy of a link\n\nA link can be either an instance of the `ApolloLink` class or a subclass of it. Regardless, it must define a method named `request` that:\n\n* Accepts an `Operation` object and a `forward` function\n* Returns an Observable, usually by calling the `forward` function\n\nThis `request` method is known as the link's **request handler**.\n\nHere's an example of a custom link that defines its request handler by passing it as a parameter to the `ApolloLink` constructor:\n\n```js\nimport { ApolloLink } from '@apollo/client';\n\nconst timeStartLink = new ApolloLink((operation, forward) => {\n  operation.setContext({ start: new Date() });\n  return forward(operation);\n});\n```\n\n> Apollo Link uses the Observables implementation provided by [`zen-observable`](https://github.com/zenparsing/zen-observable). Refer to the `zen-observable` documentation for additional `Observable` API details.\n\n### The request handler\n\nEvery link defines a `request` method, also known as its **request handler**. This method takes the following arguments:\n\n- `operation`: The GraphQL operation that's being passed through the link. For details, see [The `Operation` object](#the-operation-object).\n- `forward`: A function for executing the next link in the chain (unless this is a [terminating link](#the-terminating-link)).\n\nWhenever Apollo Client prepares to execute a GraphQL operation, it calls the request handler on the first link in the chain. It's the responsibility of each link to perform its intended operation and then pass execution along to the next link in the chain by calling the [`forward` function](#the-forward-function).\n\n#### The `Operation` object\n\nThe `Operation` object includes the following fields:\n\n| Name  | Description  |\n|---|---|\n| `query`  | A `DocumentNode` (parsed GraphQL operation) that describes the operation taking place.  |\n| `variables`  | A map of GraphQL variables being sent with the operation.  |\n| `operationName`  | A string name of the query if it is named, otherwise `null`.  |\n| `extensions`  |  A map to store extensions data to be sent to the server. |\n| `getContext`  | A function to return the context of the request. This context can be used by links to determine which actions to perform. See [Managing context](#managing-context). |\n| `setContext`  |  A function that takes either a new context object, or a function which takes in the previous context and returns a new one. See [Managing context](#managing-context). |\n\n#### The `forward` function\n\nWhen a link's request handler is done executing its logic, it should return a call to the `forward` function that's passed to it (unless it's the chain's [terminating link](#the-terminating-link)). Calling the `forward` function passes execution along to the next link in the chain.\n\nYou can use Apollo Link helper functions from the `@apollo/client` package to compose  your links. These functions are members of the `ApolloLink` class itself, and are explained in further detail in [Composing a link chain](#composing-a-link-chain).\n\n## Composing a link chain\n\nEach link should represent a self-contained modification to a GraphQL operation. By composing these links into a chain, you can create an arbitrarily complex model for your client's data flow.\n\nThere are two forms of link composition: **additive** and **directional**.\n\n* Additive composition involves combining a set of links into a serially executed chain.\n* Directional composition involves branching to one of multiple links, depending on the details of an operation.\n\nNote that no matter how you structure your links, the [terminating link](#the-terminating-link) _must_ be last.\n\n### The terminating link\n\nThe **terminating link** is the last link in your composed chain. Instead of calling the `forward` function, it's responsible for sending your composed GraphQL operation to the destination that will execute it (usually a GraphQL server) and returning an `ExecutionResult`.\n\n### Additive composition\n\nIf you have a collection of two or more links that should always be executed in the exact same order, you can use the `ApolloLink.from` helper method to combine those links into a _single_ link, like so:\n\n```js\nimport { from, HttpLink } from '@apollo/client';\nimport { RetryLink } from '@apollo/client/link/retry';\nimport MyAuthLink from '../auth';\n\nconst link = from([\n  new RetryLink(),\n  new MyAuthLink(),\n  new HttpLink({ uri: 'http://localhost:4000/graphql' })\n]);\n```\n\n### Directional composition\n\nYou might want your link chain's execution to branch, depending on the details of the operation being performed. You can define this logic with the `split` method of an `ApolloLink` instance. This method takes three parameters:\n\n| Name  | Description  |\n|---|---|\n| `test`  | A function that takes in the current `Operation` and returns either `true` or `false` depending on its details.  |\n| `left`  | The link to execute next if the `test` function returns `true`.  |\n| `right`  | An **optional** link to execute next if the `test` function returns `false`. If this is not provided, the link's `forward` parameter is used. |\n\nIn the following example, a `RetryLink` passes execution along to one of two different `HttpLink`s depending on the associated context's `version`:\n\n```js\nimport { ApolloLink, HttpLink } from '@apollo/client';\nimport { RetryLink } from '@apollo/client/link/retry';\n\nconst link = new RetryLink().split(\n  (operation) => operation.getContext().version === 1,\n  new HttpLink({ uri: \"http://localhost:4000/v1/graphql\" }),\n  new HttpLink({ uri: \"http://localhost:4000/v2/graphql\" })\n);\n```\n\nOther uses for the `split` method include:\n\n* Customizing the number of allowed retry attempts depending on the operation type\n* Using different transport methods depending on the operation type (such as HTTP for queries and WebSocket for subscriptions)\n* Customizing logic depending on whether a user is logged in\n\n\n## Link types\n\n\n### Stateless links\n\nMost links perform the same logic for every operation they process, and they don't need to know anything about operations that have been executed previously. These links are **stateless**.\n\nYou can define the request handler for a stateless link in the constructor of an `ApolloLink` object, like so:\n\n```js\nimport { ApolloLink } from '@apollo/client';\n\nconst consoleLink = new ApolloLink((operation, forward) => {\n  console.log(`starting request for ${operation.operationName}`);\n  return forward(operation).map((data) => {\n    console.log(`ending request for ${operation.operationName}`);\n    return data;\n  })\n})\n```\n\nStateless links are great for implementing middleware and even network requests. The following link adds an `Authorization` header to every outgoing request:\n\n```js\nimport { ApolloLink } from '@apollo/client';\n\nconst authLink = new ApolloLink((operation, forward) => {\n  operation.setContext(({ headers }) => ({ headers: {\n    authorization: Auth.userId(), // however you get your token\n    ...headers\n  }}));\n  return forward(operation);\n});\n```\n\nThis style of link also composes well for customization using a function:\n\n```js\nimport { ApolloLink } from '@apollo/client';\n\nconst reportErrors = (errorCallback) => new ApolloLink((operation, forward) => {\n  const observable = forward(operation);\n  // errors will be sent to the errorCallback\n  observable.subscribe({ error: errorCallback })\n  return observable;\n});\n\nconst link = reportErrors(console.error);\n```\n\n#### Extending `ApolloLink`\n\nYou can also create a stateless link by extending the `ApolloLink` class and overwriting its constructor and request handler. For example, here's the same `reportErrors` link written as an extension of `ApolloLink`:\n\n```js\nimport { ApolloLink } from '@apollo/client';\n\nclass ReportErrorLink extends ApolloLink {\n  constructor(errorCallback) {\n    super();\n    this.errorCallback = errorCallback;\n  }\n  request(operation, forward) {\n    const observable = forward(operation);\n    // errors will be sent to the errorCallback\n    observable.subscribe({ error: this.errorCallback })\n    return observable;\n  }\n}\n\nconst link = new ReportErrorLink(console.error);\n```\n\n### Stateful links\n\nWhen it's useful, links can maintain state between operations. These links are **stateful**.\n\nStateful links are usually defined as subclasses of `ApolloLink`. They override the constructor of `ApolloLink` and implement a `request` function with the same signature as a stateless link. For example:\n\n```js\nimport { ApolloLink } from '@apollo/client';\n\nclass OperationCountLink extends ApolloLink {\n  constructor() {\n    super();\n    this.operationCount = 0;\n  }\n  request(operation, forward) {\n    this.operationCount += 1;\n    return forward(operation);\n  }\n}\n\nconst link = new OperationCountLink();\n```\n\nThis stateful link maintains a counter called `operationCount` as an instance variable. Every time a request is passed through the link, `operationCount` is incremented.\n\n## Managing context\n\nAs an operation moves down your link chain, it maintains a `context` that each link can read and modify. This allows links to pass metadata down the chain that _other_ links use in their execution logic.\n\n* Obtain the current context object by calling `operation.getContext()`.\n* Modify the context object and then write it back with `operation.setContext(newContext)` or `operation.setContext((prevContext) => newContext)`.\n\nNote that this context is *not* included with the operation in the terminating link's request to the GraphQL server or other destination.\n\nHere's an example:\n\n```js\nimport { ApolloLink } from '@apollo/client';\n\nconst timeStartLink = new ApolloLink((operation, forward) => {\n  operation.setContext({ start: new Date() });\n  return forward(operation);\n});\n\nconst logTimeLink = new ApolloLink((operation, forward) => {\n  return forward(operation).map((data) => {\n    // data from a previous link\n    const time = new Date() - operation.getContext().start;\n    console.log(`operation ${operation.operationName} took ${time} to complete`);\n    return data;\n  })\n});\n\nconst link = timeStartLink.concat(logTimeLink)\n```\n\nThis example defines two links, `timeStartLink` and `logTimeLink`. The `timeStartLink` assigns the current time to the context's `start` field. When the operation completes, the `logTimeLink` then subtracts the value of `start` from the current time to determine the total duration of the operation.\n\nThe context's initial value can be set by Apollo Client before the link chain begins its execution. In this example, a call to `client.query` adds a `saveOffline` field to the context, which is then read by the custom link defined at the top:\n\n```js\nimport { ApolloLink, InMemoryCache } from '@apollo/client';\n\nconst link = new ApolloLink((operation, forward) => {\n  const { saveOffline } = operation.getContext();\n  if (saveOffline) // do offline stuff\n  return forward(operation);\n})\n\nconst client = new ApolloClient({\n  cache: new InMemoryCache()\n  link,\n});\n\n// send context to the link\nconst query = client.query({ query: MY_GRAPHQL_QUERY, context: { saveOffline: true }});\n```\n"}},"__N_SSG":true}