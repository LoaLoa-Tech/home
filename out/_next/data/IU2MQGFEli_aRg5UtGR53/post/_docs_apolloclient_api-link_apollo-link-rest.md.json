{"pageProps":{"markdownPost":{"name":null,"url":null,"content":"---\ntitle: REST Link\ndescription: Call REST APIs inside your GraphQL queries.\n---\n\n## Overview\n\nCalling REST APIs from a GraphQL client opens the benefits of GraphQL for more people, whether:\n\n* You are in a front-end developer team that wants to try GraphQL without asking for the backend team to implement a GraphQL server.\n* You have no access to change the backend because it's an existing set of APIs, potentially managed by a 3rd party.\n* You have an existing codebase, but you're looking to evaluate whether GraphQL can work for your needs.\n* You have a large codebase, and the GraphQL migration is happening on the backend, but you want to use GraphQL *now* without waiting!\n\nWith `apollo-link-rest`, you can call your endpoints inside your GraphQL queries and have all your data managed by Apollo Client. `apollo-link-rest` is suitable for just dipping your toes in the water, or doing a full-steam ahead integration, and then later on migrating to a backend-driven GraphQL experience.\n\n> For more advanced or complex back-ends, you may want to consider using [`apollo-server`](https://www.apollographql.com/docs/apollo-server/).\n\n## Quick start\n\nTo get started, first install Apollo Client and any `peerDependencies` we need:\n\n```bash\nnpm install --save @apollo/client apollo-link-rest graphql qs\n```\n\nAfter this, you're ready to setup the Apollo Client instance:\n\n```js\nimport { ApolloClient, InMemoryCache } from '@apollo/client';\nimport { RestLink } from 'apollo-link-rest';\n\n// Set `RestLink` with your endpoint\nconst restLink = new RestLink({ uri: \"https://swapi.dev/api/\" });\n\n// Setup your client\nconst client = new ApolloClient({\n  cache: new InMemoryCache(),\n  link: restLink\n});\n```\n\nNow it's time to write our first query. Defining a query is straightforward:\n\n```js\nimport { gql } from '@apollo/client';\n\nconst query = gql`\n  query Luke {\n    person @rest(type: \"Person\", path: \"people/1/\") {\n      name\n    }\n  }\n`;\n```\n\nYou can then fetch your data using Apollo Client:\n\n```js\n// Invoke the query and log the person's name\nclient.query({ query }).then(response => {\n  console.log(response.data.name);\n});\n```\n\n## Options\n\nThe `RestLink` constructor accepts an options object that can be used to customize the behavior of the link. Supported options are outlined below:\n\n| Option | Type | Description |\n| - | - | - |\n| `uri` | `string` | The URI key is a string endpoint/domain for your requests to hit (_optional_ when `endpoints` provides a default) |\n| `endpoints: /map-of-endpoints/` | `any` | _optional_ A map of endpoints. If you use this, you need to provide `endpoint` to the `@rest(...)` directives. |\n| `customFetch?` | `any` | _optional_ A custom `fetch` to handle `REST` calls |\n| `headers?` | `Headers` | _optional_ An object representing values to be sent as headers with all requests. [Documented here](https://developer.mozilla.org/en-US/docs/Web/API/Request/headers) |\n| `credentials?` | `string` | _optional_ A string representing the credentials policy the fetch call should operate with. [Document here](https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials) |\n| `fieldNameNormalizer?: /function/` | `any` | _optional_ A function that takes the response field name and converts it into a GraphQL compliant name. This is useful if your `REST` API returns fields that aren't representable as GraphQL, or if you want to convert between `snake_case` field names in JSON to `camelCase` keyed fields. |\n| `fieldNameDenormalizer?: /function/` | `any` | _optional_ A function that takes a GraphQL-compliant field name and converts it back into an endpoint-specific name. |\n| `typePatcher: /map-of-functions/` | `any` | _optional_ A structure to allow you to specify the `__typename` when you have nested objects in your REST response. |\n| `defaultSerializer /function/` | `any` | _optional_ A function that will be used by the `RestLink` as the default serializer when no `bodySerializer` is defined for a `@rest` call. The function will also be passed the current `Header` set, which can be updated before the request is sent to `fetch`. Default method uses `JSON.stringify` and sets the `Content-Type` to `application/json`. |\n| `bodySerializers: /map-of-functions/` | `any` | _optional_ Structure to allow the definition of alternative serializers, which can then be specified by their key. |\n| `responseTransformer?: /function/` | `any` | _optional_ Apollo expects a record response to return a root object, and a collection of records response to return an array of objects. Use this function to structure the response into the format Apollo expects if your response data is structured differently. |\n\n### Multiple endpoints\n\nIf you want to be able to use multiple endpoints, you can create your link like:\n\n```js\nconst link = new RestLink({ endpoints: { v1: 'api.com/v1', v2: 'api.com/v2' } });\n```\n\nYou then need to specify the endpoint you want to use, in the rest directive:\n\n```js\nconst postTitleQuery1 = gql`\n  query PostTitle {\n    post @rest(type: \"Post\", path: \"/post\", endpoint: \"v1\") {\n      id\n      title\n    }\n  }\n`;\nconst postTitleQuery2 = gql`\n  query PostTitle {\n    post @rest(type: \"[Tag]\", path: \"/tags\", endpoint: \"v2\") {\n      id\n      tags\n    }\n  }\n`;\n```\n\nIf you have a default endpoint, you can create your link like:\n\n```js\nconst link = new RestLink({\n  endpoints: { github: 'github.com' },\n  uri: 'api.com',\n});\n```\n\nIf you don't specify an endpoint in your query, the default endpoint (the one you specify in the `uri` option) will be used.\n\n### Typename patching\n\nWhen sending a query like:\n\n```graphql\nquery MyQuery {\n  planets @rest(type: \"PlanetPayload\", path: \"planets/\") {\n    count\n    next\n    results {\n      name\n    }\n  }\n}\n```\n\nthe outer response object (`data.planets`) gets its `__typename: \"PlanetPayload\"` from the [`@rest(...)` directive's `type` parameter](#rest-directive). You, however, need to have a way to set the typename of `PlanetPayload.results`.\n\nOne way you can do this is by providing a `typePatcher`:\n\n```typescript\nconst restLink = new RestLink({\n  uri: '/api',\n  typePatcher: {\n    PlanetPayload: (\n      data: any,\n      outerType: string,\n      patchDeeper: RestLink.FunctionalTypePatcher,\n    ): any => {\n      if (data.results != null) {\n        data.results =\n          data.results.map(planet => ({ __typename: \"Planet\", ...planet }));\n      }\n      return data;\n    },\n    // ... other nested type patchers\n  },\n})\n```\n\nIf you have a very lightweight REST integration, you can use the `@type(name: ...)` directive.\n\n```graphql\nquery MyQuery {\n  planets @rest(type: \"PlanetPayload\", path: \"planets/\") {\n    count\n    next\n    results @type(name: \"Planet\") {\n      name\n    }\n  }\n}\n```\n\nThis is appropriate if you have a small list of nested objects. The cost of this strategy is that every query that deals with these objects needs to also include `@type(name: ...)`, which means this approach can be quite verbose and error prone.\n\nYou can also use both of these approaches in tandem:\n\n```graphql\nquery MyQuery {\n  planets @rest(type: \"PlanetPayload\", path: \"planets/\") {\n    count\n    next\n    results @type(name: \"Results\") {\n      name\n    }\n    typePatchedResults {\n      name\n    }\n  }\n}\n```\n\n```typescript\nconst restLink = new RestLink({\n  uri: '/api',\n  typePatcher: {\n    PlanetPayload: (\n      data: any,\n      outerType: string,\n      patchDeeper: RestLink.FunctionalTypePatcher,\n    ): any => {\n      if (data.typePatchedResults != null) {\n        data.typePatchedResults =\n          data.typePatchedResults.map(planet => { __typename: \"Planet\", ...planet });\n      }\n      return data;\n    },\n    // ... other nested type patchers\n  },\n})\n```\n\n#### Warning\n\nIt's important to note that at the moment the `typePatcher` is not able to act on nested objects within annotated `@type` objects. For instance, `failingResults` will not be patched if you define it on the `typePatcher`:\n\n```graphql\nquery MyQuery {\n  planets @rest(type: \"PlanetPayload\", path: \"planets/\") {\n    count\n    next\n    results @type(name: \"Planet\") {\n      name\n      failingResults {\n        name\n      }\n    }\n    typePatchedResults {\n      name\n    }\n  }\n}\n```\n\nTo make this work you should try to pick one strategy, and stick with it -- either all `typePatcher` or all `@type` directives.\n\n### Response transforming\n\nBy default, Apollo expects an object at the root for record requests, and an array of objects at the root for collection requests. For example, if fetching a user by ID (`/users/1`), the following response is expected.\n\n```json\n{\n  \"id\": 1,\n  \"name\": \"Apollo\"\n}\n```\n\nAnd when fetching for a list of users (`/users`), the following response is expected.\n\n```json\n[\n  {\n    \"id\": 1,\n    \"name\": \"Apollo\"\n  },\n  {\n    \"id\": 2,\n    \"name\": \"Starman\"\n  }\n]\n```\n\nIf the structure of your API responses differs than what Apollo expects, you can define a `responseTransformer` in the client. This function receives the response object as the 1st argument, and the current `typeName` as the 2nd argument. It should return a `Promise` as it will be responsible for reading the response stream by calling one of `json()`, `text()` etc.\n\nFor example, if the record is not at the root level:\n\n```json\n{\n  \"meta\": {},\n  \"data\": [\n    {\n      \"id\": 1,\n      \"name\": \"Apollo\"\n    },\n    {\n      \"id\": 2,\n      \"name\": \"Starman\"\n    }\n  ]\n}\n```\n\nThe following transformer could be used to support it:\n\n```js\nconst link = new RestLink({\n  uri: '/api',\n  responseTransformer: async response => response.json().then(({data}) => data),\n});\n```\n\nPlaintext, XML, or otherwise-encoded responses can be handled by manually parsing and converting them to JSON (using the previously described format that Apollo expects):\n\n```js\nconst link = new RestLink({\n  uri: '/xmlApi',\n  responseTransformer: async response => response.text().then(text => parseXmlResponseToJson(text)),\n});\n```\n\n### Custom endpoint responses\n\nThe client level `responseTransformer` applies for all responses, across all URIs and endpoints. If you need a custom `responseTransformer` per endpoint, you can define an object of options for that specific endpoint.\n\n```js\nconst link = new RestLink({\n  endpoints: {\n    v1: {\n      uri: '/v1',\n      responseTransformer: async response => response.data,\n    },\n    v2: {\n      uri: '/v2',\n      responseTransformer: async (response, typeName) => response[typeName],\n    },\n  },\n});\n```\n\n> When using the object form, the `uri` field is required.\n\n### Custom Fetch\n\nBy default, Apollo uses the browsers `fetch` method to handle `REST` requests to your domain/endpoint. The `customFetch` option allows you to specify _your own_ request handler by defining a function that returns a `Promise` with a fetch-response-like object:\n\n```js\nconst link = new RestLink({\n  endpoints: \"/api\",\n  customFetch: (uri, options) => new Promise((resolve, reject) => {\n    // Your own (asynchronous) request handler\n    resolve(responseObject)\n  }),\n});\n```\n\nTo resolve your GraphQL queries quickly, Apollo will issue requests to relevant endpoints as soon as possible. This is generally ok, but can lead to large numbers of `REST` requests to be fired at once; especially for deeply nested queries [(see `@export` directive)](#export-directive).\n\n> Some endpoints (like public APIs) might enforce _rate limits_, leading to failed responses and unresolved queries in such cases.\n\nBy example, `customFetch` is a good place to manage your apps fetch operations. The following implementation makes sure to only issue 2 requests at a time (concurrency) while waiting at least 500ms until the next batch of requests is fired.\n\n```js\nimport pThrottle from \"p-throttle\";\n\nconst link = new RestLink({\n  endpoints: \"/api\",\n  customFetch: pThrottle((uri, config) => {\n      return fetch(uri, config);\n    },\n    2, // Max. concurrent Requests\n    500 // Min. delay between calls\n  ),\n});\n```\n> Since Apollo issues `Promise` based requests, we can resolve them as we see fit. This example uses [`pThrottle`](https://github.com/sindresorhus/p-throttle); part of the popular [promise-fun](https://github.com/sindresorhus/promise-fun) collection.\n\n### Complete options\n\nHere is one way you might customize `RestLink`:\n\n```js\nimport fetch from 'cross-fetch';\nimport * as camelCase from 'camelcase';\nimport * as snake_case from 'snake-case';\n\nconst link = new RestLink({\n  endpoints: { github: 'github.com' },\n  uri: 'api.com',\n  customFetch: fetch,\n  headers: {\n    \"Content-Type\": \"application/json\"\n  },\n  credentials: \"same-origin\",\n  fieldNameNormalizer: (key: string) => camelCase(key),\n  fieldNameDenormalizer: (key: string) => snake_case(key),\n  typePatcher: {\n    Post: ()=> {\n      bodySnippet...\n    }\n  },\n  defaultSerializer: (data: any, headers: Headers) => {\n    const formData = new FormData();\n    for (let key in body) {\n      formData.append(key, body[key]);\n    }\n    headers.set(\"Content-Type\", \"x-www-form-encoded\")\n    return {body: formData, headers};\n  }\n});\n```\n\n## Link Context\n\n`RestLink` has an [interface `LinkChainContext`](https://github.com/apollographql/apollo-link-rest/blob/1824da47d5db77a2259f770d9c9dd60054c4bb1c/src/restLink.ts#L557-L570) which it uses as the structure of things that it will look for in the `context`, as it decides how to fulfill a specific `RestLink` request. (Please see the [`@apollo/client/link/context`](./apollo-link-context) page for a discussion of why you might want this).\n\n| Option | Type | Description |\n| - | - | - |\n| `credentials?` | `RequestCredentials` | Overrides the `RestLink`-level setting for `credentials`. [Values documented here](https://developer.mozilla.org/en-US/docs/Web/API/Request/headers) |\n| `headers?` | `Headers` | Additional headers provided in this `context-link` [Values documented here](https://developer.mozilla.org/en-US/docs/Web/API/Request/headers) |\n| `headersToOverride?` | `string[]` | If you provide this array, we will merge the headers you provide in this link, by replacing any matching headers that exist in the root `RestLink` configuration. Alternatively you can use `headersMergePolicy` for more fine-grained customization of the merging behavior. |\n| `headersMergePolicy?` | `RestLink.HeadersMergePolicy` | This is a function that decide how the headers returned in this `contextLink` are merged with headers defined at the `RestLink`-level. If you don't provide this, the headers will be simply appended. To use this option, you can provide your own function that decides how to process the headers. [Code references](https://github.com/apollographql/apollo-link-rest/blob/8e57cabb5344209d9cfa391c1614fe8880efa5d9/src/restLink.ts#L462-L510) |\n| `restResponses?` | `Response[]` | This will be populated after the operation has completed with the [Responses](https://developer.mozilla.org/en-US/docs/Web/API/Response) of every REST url fetched during the operation. This can be useful if you need to access the response headers to grab an authorization token for example. |\n\n### Example\n\n`RestLink` uses the `headers` field on the [`@apollo/client/link/context`](./apollo-link-context) so you can compose other links that provide additional & dynamic headers to a given query.\n\nHere is one way to add request `headers` to the context and retrieve the response headers of the operation:\n\n```js\nconst authRestLink = new ApolloLink((operation, forward) => {\n  operation.setContext(({headers}) => {\n    const token = localStorage.getItem(\"token\");\n    return {\n      headers: {\n        ...headers,\n        Accept: \"application/json\",\n        Authorization: token\n      }\n    };\n  });\n  return forward(operation).map(result => {\n    const { restResponses } = operation.getContext();\n    const authTokenResponse = restResponses.find(res => res.headers.has(\"Authorization\"));\n    // You might also filter on res.url to find the response of a specific API call\n    if (authTokenResponse) {\n      localStorage.setItem(\"token\", authTokenResponse.headers.get(\"Authorization\"));\n    }\n    return result;\n  });\n});\n\nconst restLink = new RestLink({ uri: \"uri\" });\n\nconst client = new ApolloClient({\n  cache: new InMemoryCache(),\n  link: ApolloLink.from([authRestLink, restLink])\n});\n```\n\n## Link order\n\nIf you are using multiple link types, `restLink` should go before `httpLink`, as `httpLink` will swallow any calls that should be routed through `apollo-link-rest`.\n\nFor example:\n\n```js\nconst httpLink = createHttpLink({ uri: \"server.com/graphql\" });\nconst restLink = new RestLink({ uri: \"api.server.com\" });\n\nconst client = new ApolloClient({\n  cache: new InMemoryCache(),\n  link: ApolloLink.from([authLink, restLink, errorLink, retryLink, httpLink])\n  // Note: httpLink is terminating so must be last, while retry & error wrap\n  // the links to their right. State & context links should happen before (to\n  // the left of) restLink.\n});\n```\n\n_Note: you should also consider this if you're using [`@apollo/client/link/context`](./apollo-link-context) to set `Headers`, you need that link to be before `restLink` as well._\n\n## @rest directive\n\nThis is where you setup the endpoint you want to fetch. The rest directive can be used at any depth in a query.\n\n### Arguments\n\nAn `@rest(…)` directive takes two required and several optional arguments:\n\n| Option | Type | Description |\n| - | - | - |\n| `type` | `string` | The GraphQL type this will return |\n| `path` | `string` | uri-path to the REST API. This could be a path or a full url. If a path, the endpoint given on link creation or from the context is concatenated with it to produce a full `URI`. See also: `pathBuilder` |\n| `method?` | `GET`  `PUT` `POST` `DELETE` | The HTTP method to send the request via (i.e GET, PUT, POST) |\n| `endpoint?` | `string` | Key to use when looking up the endpoint in the (optional) `endpoints` table if provided to RestLink at creation time. |\n| `pathBuilder?: /function/` | `string` | If provided, this function gets to control what path is produced for this request. |\n| `bodyKey?: \"input\"` | `string` | This is the name of the `variable` to use when looking to build a REST request-body for a `PUT` or `POST` request. It defaults to `input` if not supplied. |\n| `bodyBuilder?: /function/` | `string` | If provided, this is the name a `function` that you provided to `variables`, that is called when a request-body needs to be built. This lets you combine arguments or encode the body in some format other than JSON. |\n| `bodySerializer?: /string | function/` | `string` | String key to look up a function in `bodySerializers` or a custom serialization function for the body/headers of this request before it is passed to the fetch call. Defaults to `JSON.stringify` and setting `Content-Type: application-json`. |\n\n### Variables\n\nYou can use query `variables` inside nested queries, or in the the path argument of your directive:\n\n```graphql\nquery PostTitle {\n  post(id: \"1\") @rest(type: \"Post\", path: \"/post/{args.id}\") {\n    id\n    title\n  }\n}\n```\n\n> **Warning**: Variables in the main path will not automatically have `encodeURIComponent` called on them.\n\nAdditionally, you can also control the query-string:\n\n```graphql\nquery PostTitle {\n  postSearch(query: \"some key words\", page_size: 5)\n    @rest(type: \"Post\", path: \"/search?{args}&{context.language}\") {\n    id\n    title\n  }\n}\n```\n\nThings to note:\n\n1. This will be converted into `/search?query=some%20key%20words&page_size=5&lang=en`\n2. The `context.language / lang=en` is extracting an object from the Apollo Context, that was added via an `@apollo/client/link/context` Link.\n3. The query string arguments are assembled by npm:qs and have `encodeURIComponent` called on them.\n\nThe available variable sources are:\n\n| Option | Description |\n| - | - |\n| `args` | These are the things passed directly to this field parameters. In the above example `postSearch` had `query` and `page_size` in args. |\n| `exportVariables` | These are the things in the parent context that were tagged as `@export(as: ...)` |\n| `context` | These are the apollo-context, so you can have globals set up via `@apollo/client/link/context` |\n| `@rest` | These include any other parameters you pass to the `@rest()` directive. This is probably more useful when working with `pathBuilder`, documented below. |\n\n#### `pathBuilder`\n\nIf the variable-replacement options described above aren't enough, you can provide a `pathBuilder` to your query. This will be called to dynamically construct the path. This is considered an advanced feature, and is documented in the source -- it also should be considered syntactically unstable, and we're looking for feedback!\n\n#### `bodyKey` / `bodyBuilder`\n\nWhen making a `POST` or `PUT` HTTP request, you often need to provide a request body. By [convention](https://graphql.org/graphql-js/mutations-and-input-types/), GraphQL recommends you name your input-types as `input`, so by default that's where we'll look to find a JSON object for your body.\n\n##### `bodyKey`\n\nIf you need/want to name it something different, you can pass `bodyKey`, and we'll look at that variable instead.\n\nIn this example the publish API accepts a body in the variable `body` instead of input:\n\n```graphql\nmutation PublishPost(\n  $someApiWithACustomBodyKey: PublishablePostInput!\n) {\n  publishedPost: publish(input: \"Foo\", body: $someApiWithACustomBodyKey)\n    @rest(\n      type: \"Post\"\n      path: \"/posts/{args.input}/new\"\n      method: \"POST\"\n      bodyKey: \"body\"\n    ) {\n    id\n    title\n  }\n}\n```\n\n[Unit Test](https://github.com/apollographql/apollo-link-rest/blob/c9d81ae308e5f61b5ae992061de7abc6cb2f78e0/src/__tests__/restLink.ts#L1803-L1846)\n\n##### `bodyBuilder`\n\nIf you need to structure your data differently, or you need to custom encode your body (say as form-encoded), you can provide `bodyBuilder` instead:\n\n```graphql\nmutation EncryptedPost(\n  $input: PublishablePostInput!\n  $encryptor: any\n) {\n  publishedPost: publish(input: $input)\n    @rest(\n      type: \"Post\"\n      path: \"/posts/new\"\n      method: \"POST\"\n      bodyBuilder: $encryptor\n    ) {\n    id\n    title\n  }\n}\n```\n\n[Unit Test](https://github.com/apollographql/apollo-link-rest/blob/c9d81ae308e5f61b5ae992061de7abc6cb2f78e0/src/__tests__/restLink.ts#L1847-L1904)\n\n##### `bodySerializer`\n\nIf you need to serialize your data differently (say as form-encoded), you can provide a `bodySerializer` instead of relying on the default JSON serialization.\n`bodySerializer` can be either a function of the form `(data: any, headers: Headers) => {body: any, header: Headers}` or a string key. When using the string key\n`RestLink` will instead use the corresponding serializer from the `bodySerializers` object, that can optionally be passed in during initialization.\n\n```graphql\nmutation EncryptedForm(\n  $input: PublishablePostInput!,\n  $formSerializer: any\n) {\n  publishedPost: publish(input: $input)\n    @rest(\n      type: \"Post\",\n      path: \"/posts/new\",\n      method: \"POST\",\n      bodySerializer: $formSerializer\n    ) {\n      id\n      title\n    }\n\n  publishRSS(input: $input)\n    @rest(\n      type: \"Post\",\n      path: \"/feed\",\n      method: \"POST\",\n      bodySerializer: \"xml\"\n    )\n}\n```\n\nWhere `formSerializer` could be defined as\n\n```typescript\nconst formSerializer = (data: any, headers: Headers) => {\n  const formData = new FormData();\n  for (let key in data) {\n    if (data.hasOwnProperty(key)) {\n      formData.append(key, data[key]);\n    }\n  }\n\n  headers.set('Content-Type', 'application/x-www-form-urlencoded');\n\n  return {body: formData, headers};\n}\n\n```\n\nAnd `\"xml\"` would have been defined on the `RestLink` directly\n\n```typescript\nconst restLink = new RestLink({\n  ...otherOptions,\n  bodySerializers: {\n    xml: xmlSerializer\n  }\n})\n```\n\n## @export directive\n\nThe export directive re-exposes a field for use in a later (nested) query. These are the same semantics that will be supported on the server, but when used in a `RestLink` you can use the exported variables for further calls (i.e. waterfall requests from nested fields).\n\n_Note: If you're constantly using @export you may prefer to take a look at [`apollo-server`](https://www.apollographql.com/docs/apollo-server/)._\n\n### Arguments\n\n* `as: string`: name to create this as a variable to be used down the selection set\n\n### Example\n\nAn example use-case would be getting a list of users, and hitting a different endpoint to fetch more data using the exported field in the REST query args.\n\n```graphql\nconst QUERY = gql`\n  query RestData($email: String!) {\n    users @rest(path: '/users/email?{args.email}', method: 'GET', type: 'User') {\n      id @export(as: \"id\")\n      firstName\n      lastName\n      friends @rest(path: '/friends/{exportVariables.id}', type: '[User]') {\n        firstName\n        lastName\n      }\n    }\n  }\n`;\n```\n\n## Mutations\n\nYou can write also mutations with the apollo-link-rest, for example:\n\n```graphql\nmutation DeletePost($id: ID!) {\n  deletePostResponse(id: $id)\n    @rest(type: \"Post\", path: \"/posts/{args.id}\", method: \"DELETE\") {\n    NoResponse\n  }\n}\n```\n\n## Troubleshooting\n\nHere are a few common `apollo-link-rest` problems and solutions.\n\n* `Missing field __typename in ...` -- If you see this, it's possible you haven't provided `type:` to the [`@rest(...)`](#rest-directive)-directive. Alternately you need to set up a [`typePatcher`](#typename-patching).\n* `Headers is undefined` -- If you see something like this, you're running in a browser or other Javascript environment that does not yet support the full specification for the `Headers` API.\n\n## Example apps\n\nTo get you started, here are some example apps:\n\n* [Simple](https://github.com/apollographql/apollo-link-rest/tree/master/examples/simple):\n  A very simple app with a single query that reflects the setup section.\n* [Advanced](https://github.com/apollographql/apollo-link-rest/tree/master/examples/advanced):\n  A more complex app that demonstrates how to use an export directive.\n\n## Contributing\n\nPlease join us on github [apollographql/apollo-link-rest](https://github.com/apollographql/apollo-link-rest/) and in [Spectrum](https://spectrum.chat/apollo).\n"}},"__N_SSG":true}