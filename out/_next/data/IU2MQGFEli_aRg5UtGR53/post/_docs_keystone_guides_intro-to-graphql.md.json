{"pageProps":{"markdownPost":{"name":null,"url":null,"content":"<!--[meta]\nsection: guides\ntitle: Introduction\nsubSection: graphql\norder: 1\n[meta]-->\n\n# GraphQL API Introduction\n\n_Before you begin:_ This guide assumes you have a running instance of Keystone with the GraphQL App configured, and a list with some data to query. (Get started in 5min by running `npx create-keystone-app` and select the `Starter` project)\n\nExamples in this guide will refer to a `Users` list, however the queries, mutations and methods listed here would be the same for any Keystone list.\n\nFor each list, Keystone generates four top level queries. Given the following example:\n\n```javascript\nkeystone.createList('User', {\n  fields: {\n    name: { type: Text },\n  },\n});\n```\n\n## Queries\n\nKeystone would generate the following queries:\n\n- `allUsers`\n- `_allUsersMeta`\n- `User`\n- `_UsersMeta`\n\n### `allUsers`\n\nRetrieves all items from the `User` list. The `allUsers` query also allows you to search, limit and filter results. See: [Filter, limit and sorting](#filter-limit-and-sorting).\n\n```graphql\nquery {\n  allUsers {\n    id\n  }\n}\n```\n\n### `_allUsersMeta`\n\nRetrieves meta information about items in the `User` list such as a `count` of all items which can be used for pagination. The `_allUsersMeta` query accepts the same [filter, limit and sorting](#filter-limit-and-sorting) parameters as the `allUsers` query.\n\n```graphql\nquery {\n  _allUsersMeta {\n    count\n  }\n}\n```\n\n### `User`\n\nRetrieves a single item from the `User` list. The single entity query accepts a where parameter which must provide an id.\n\n```graphql\nquery {\n  User(where: { id: $id }) {\n    name\n  }\n}\n```\n\n### `_UsersMeta`\n\nRetrieves meta information about the `User` list itself (i.e. not about items in the list) such as access control information. This query accepts no parameters.\n\n## Mutations\n\nFor each list Keystone generates six top level mutations:\n\n- `createUser`\n- `createUsers`\n- `updateUser`\n- `updateUsers`\n- `deleteUser`\n- `deleteUsers`\n\n### `createUser`\n\nAdd a single `User` to the `User` list. Requires a `data` parameter that is an object where keys match the field names in the list definition and the values are the data to create.\n\n```graphql\nmutation {\n  createUser(data: { name: \"Mike\" }) {\n    id\n  }\n}\n```\n\n### `createUsers`\n\nCreates multiple `Users`. Parameters are the same as `createUser` except the data parameter should be an array of objects.\n\n```graphql\nmutation {\n  createUsers(data: [{ data: { name: \"Mike\" } }, { data: { name: \"Maher\" } }]) {\n    id\n    name\n  }\n}\n```\n\n### `updateUser`\n\nUpdate a `User` by ID. Accepts an `id` parameter that should match the id of a `User` item. The object should contain keys matching the field definition of the list. `updateUser` performs a _partial update_, meaning only keys that you wish to update need to be provided.\n\n```graphql\nmutation {\n  updateUser(id: ID, data: { name: \"Simon\" }) {\n    id\n  }\n}\n```\n\n### `updateUsers`\n\nUpdate multiple `Users` by ID. Accepts a single data parameter that contains an array of objects. The object parameters are the same as `createUser` and should contain an `id` and nested `data` parameter with the field data.\n\n```graphql\nmutation {\n  updateUsers(data: [{ id: ID, data: { name: \"Simon\" } }]) {\n    id\n  }\n}\n```\n\n### `deleteUser`\n\nDelete a single Entity by ID. Accepts a single parameter where the `id` matches a `User` id.\n\n```graphql\nmutation {\n  deleteUser(id: ID) {\n    id\n  }\n}\n```\n\n### `deleteUsers`\n\nDelete multiple entities by ID. Similar to `deleteUser` where the `id` parameter is an array of ids.\nYou can add more IDs like this `[ID1, ID2]` and don't forget to write the IDs in string format `\"\"` like this `[\"5f67974b476e6e2d58c2bfb0\", \"5f67974b476e6e2d58c2bfb1\"]`\n\n```graphql\nmutation {\n  deleteUsers(ids: [ID]) {\n    id\n  }\n}\n```\n\n## Execution\n\nBefore you begin writing application code, a great place test queries and mutations is the [GraphQL Playground](https://www.apollographql.com/docs/apollo-server/features/graphql-playground/).\nThe default path for Keystone' GraphQl Playground is `http://localhost:3000/admin/graphql`.\nHere you can execute queries and mutations against the Keystone API without writing any JavaScript.\n\nOnce you have determined the correct query or mutation, you can add this to your application. To do this you will need to submit a `POST` request to Keystone' API. The default API endpoint is: `http://localhost:3000/admin/api`.\n\nIn our examples we're going to use the browser's [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) to make a `POST` request.\n\nWe're going to write a query and store it in a variable named `GET_ALL_USERS`. Once you have a query you can execute this query using a `POST` request:\n\n```javascript\nconst GET_ALL_USERS = `\nquery GetUsers {\n  allUsers {\n    name\n    id\n  }\n}`;\n\nconst data = await fetch('/admin/api', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json',\n  },\n  body: JSON.stringify({\n    query: GET_ALL_USERS,\n  }),\n}).then(result => result.json());\n```\n\nThe result should contain a `JSON` payload with the results from the query.\n\nExecuting mutations is the same, however we need to pass variables along with the mutation. The key for mutations in the post request is still `query`. Let's write a mutation called `ADD_USER`, and pass a `variables` object along with the mutation in the `POST` request:\n\n```javascript\nconst ADD_USER = `\nmutation AddUser($name: String!) {\n  createUser(data: { name: $name }) {\n    name\n    id\n  }\n}`;\n\nconst data = await fetch('/admin/api', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json',\n  },\n  body: JSON.stringify({\n    query: ADD_USER,\n    variables: { name: 'Mike' },\n  }),\n}).then(result => result.json());\n```\n\nA good next step is to write an `executeQuery` function that accepts a query and variables and returns the results from the API. Take a look at the `todo` sample application in the `cli` for examples of this.\n\n> **Note:** If you have configured [Access Control](/docs/api/access-control.md) it can effect the result of some queries.\n\n## Execution on the server\n\nIn addition to executing queries via the API, you can execute queries and mutations on the server using [the `keystone.executeGraphQL()` method](/docs/discussions/server-side-graphql.md).\n\n## Filter, limit and sorting\n\nWhen executing queries and mutations there are a number of ways you can filter, limit and sort items. These include:\n\n- `where`\n- `search`\n- `skip`\n- `first`\n- `sortBy`\n\n### `where`\n\nLimit results to items matching the where clause. Where clauses are used to query fields in a keystone list before retrieving data.\n\nThe options available in a where clause depend on the field types.\n\n```graphql\nquery {\n  allUsers(where: { name_starts_with_i: \"A\" }) {\n    id\n  }\n}\n```\n\n> **Note:** The documentation in the GraphQL Playground provides a complete reference of filters for any field type in your application.\n\n#### Relationship `where` filters\n\n- `{relatedList}_every`: whereInput\n- `{relatedList}_some`: whereInput\n- `{relatedList}_none`: whereInput\n- `{relatedList}_is_null`: Boolean\n\n#### String `where` filters\n\n- `{Field}:` String\n- `{Field}_not`: String\n- `{Field}_contains`: String\n- `{Field}_not_contains`: String\n- `{Field}_starts_with`: String\n- `{Field}_not_starts_with`: String\n- `{Field}_ends_with`: String\n- `{Field}_not_ends_with`: String\n- `{Field}_i`: String\n- `{Field}_not_i`: String\n- `{Field}_contains_i`: String\n- `{Field}_not_contains_i`: String\n- `{Field}_starts_with_i`: String\n- `{Field}_not_starts_with_i`: String\n- `{Field}_ends_with_i`: String\n- `{Field}_not_ends_with_i`: String\n- `{Field}_in`: [String]\n- `{Field}_not_in`: [String]\n\n#### ID `where` filters\n\n- `{Field}`: ID\n- `{Field}_not`: ID\n- `{Field}_in`: [ID!]\n- `{Field}_not_in`: [ID!]\n\n#### Integer `where` filters\n\n- `{Field}`: Int\n- `{Field}_not`: Int\n- `{Field}_lt`: Int\n- `{Field}_lte`: Int\n- `{Field}_gt`: Int\n- `{Field}_gte`: Int\n- `{Field}_in`: [Int]\n- `{Field}_not_in`: [Int]\n\n#### Operators\n\nYou can combine multiple where clauses with `AND` or `OR` operators.\n\n- `AND`: [whereInput]\n- `OR`: [whereInput]\n\n```graphql\nquery {\n  allUsers(where: { OR: [{ name_starts_with_i: \"A\" }, { email_starts_with_i: \"A\" }] }) {\n    id\n  }\n}\n```\n\n### `search`\n\nWill search the list to limit results. For now, it can search only by `name` field. The `name` field must be a `Text` type.\n\n```graphql\nquery {\n  allUsers(search: \"Mike\") {\n    id\n  }\n}\n```\n\n### `sortBy`\n\nOrder results.\n\nEach list generates a GraphQL enum called `Sort{$listQueryName}By` containing possible sorting options based on its orderable fields in the format `<field>_<ASC|DESC>`. For example, a `User` list with `name` and `email` fields would add the following to the schema:\n\n```graphql\nenum SortUsersBy {\n  id_ASC\n  id_DESC\n  name_ASC\n  name_DESC\n  email_ASC\n  email_DESC\n}\n```\n\n`sortBy` accepts one or more of these enum values. If a list of values is provided, sorting is evaluated left-to-right.\n\nOrder by name descending (alphabetical order, A -> Z):\n\n```graphql\nquery {\n  allUsers(sortBy: name_DESC) {\n    id\n  }\n}\n```\n\nOrder by name descending then email ascending:\n\n```graphql title=\nquery {\n  allUsers(sortBy: [name_DESC, email_ASC]) {\n    id\n  }\n}\n```\n\n### `first`\n\nLimits the number of items returned from the query. Limits will be applied after `skip`, `sortBy`, `where` and `search` values are applied.\n\nIf fewer results are available, the number of available results will be returned.\n\n```graphql\nquery {\n  allUsers(first: 10) {\n    id\n  }\n}\n```\n\n### `skip`\n\nSkip the number of results specified. Is applied before `first` parameter, but after `sortBy`, `where` and `search` values.\n\nIf the value of `skip` is greater than the number of available results, zero results will be returned.\n\n```graphql\nquery {\n  allUsers(skip: 10) {\n    id\n  }\n}\n```\n\n## Combining query arguments\n\nWhen `first` and `skip` are used together with the `count` from `_allUsersMeta`, this is sufficient to implement pagination on the list.\n\nIt is important to provide the same `where` and `search` arguments to both the `allUser` and `_allUserMeta` queries. For example:\n\n```graphql\nquery {\n  allUsers(search: \"a\", skip: 10, first: 10) {\n    id\n  }\n  _allUsersMeta(search: \"a\") {\n    count\n  }\n}\n```\n\nWhen `first` and `skip` are used together, skip works as an offset for the `first` argument. For example`(skip:10, first:5)` selects results 11 through 15.\n\nBoth `skip` and `first` respect the values of the `where`, `search` and `sortBy` arguments.\n\n## Custom queries and mutations\n\nYou can add to Keystone's generated schema with custom types, queries, and mutations using the `keystone.extendGraphQLSchema()` method.\n\n```javascript\nkeystone.extendGraphQLSchema({\n  types: [{ type: 'type FooBar { foo: Int, bar: Float }' }],\n  queries: [\n    {\n      schema: 'double(x: Int): Int',\n      resolver: (_, { x }) => 2 * x,\n    },\n  ],\n  mutations: [\n    {\n      schema: 'double(x: Int): Int',\n      resolver: (_, { x }) => 2 * x,\n    },\n  ],\n});\n```\n"}},"__N_SSG":true}