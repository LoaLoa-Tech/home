{"pageProps":{"markdownPost":{"name":null,"url":null,"content":"<!--[meta]\nsection: discussions\ntitle: A new data schema\n[meta]-->\n\n# Arcade - A new data schema for Keystone\n\n> **Note:** This document refers to a set of package releases which are all part of one Keystone release.\n> These package releases are collectively known as the `Arcade` release of Keystone. The packages included are:\n>\n> - `@keystonejs/adapter-knex`: `9.0.0`\n> - `@keystonejs/adapter-mongoose`: `8.0.0`\n> - `@keystonejs/fields`: `9.0.0`\n> - `@keystonejs/keystone`: `8.0.0`\n> - `@keystonejs/mongo-join-builder`: `7.0.0`\n\nWe are excited to announce a **new and improved data schema** for Keystone.\nThe new data schema simplifies the way your data is stored and will unlock the development of new functionality within Keystone.\n\n> **Important:** You will need to make changes to your database to take advantage of the new data schema. Read on for details of what has changed and why, or jump straight to the [schema upgrade guide](/docs/guides/relationship-migration.md).\n\n## Background\n\nKeystone provides an extremely powerful graphQL API which includes filtering, sorting, and nested queries / mutations.\nThe full CRUD API is generated from simple `List` definitions provided by you, the developer.\nAll of this functionality is powered by our _database adapters_, which convert your graphQL queries into SQL/NoSQL queries and then convert the results back to graphQL.\n\nKeystone needs to know about, and manage, the schema of the underlying database so it can correctly construct its queries.\nWe designed our database schemas when we first developed the database adapters, and they have served us very well.\nIn particular, we have come a long way with our support for complex relationships using the database schemas we initially developed.\nBy keeping a consistent schema, users have been able to stay up to date with Keystone updates without having to make changes to their data.\n\nUnfortunately we have now outgrown this original schema.\nMore and more we are finding that [certain bugs](https://github.com/keystonejs/keystone/issues/1362) are hard to fix, and [certain features](https://github.com/keystonejs/keystone/issues/313) difficult to implement, because of the limitations of our initial design.\nWhile it has served us well, it's time for an upgrade.\n\n## The problem\n\nThe key challenge in designing our schema is how we represent relationships between lists.\nOur initial design borrowed heavily from a `MongoDB` inspired pattern, where each object was responsible for tracking its related items.\nThis made the initial implementation very simple, particularly for the `MongoDB` adapter.\nThe `PostgreSQL` adapter was more complex, as it had to emulate the patterns from `MongoDB`, but it also worked.\n\nOne of the design trade-offs in the initial schema was that we [denormalised](https://en.wikipedia.org/wiki/Denormalization) the data in order to simplify the query generation.\nThis means we stored duplicated data in the database, but we could very quickly perform lookups without requiring complex queries.\n\nUnfortunately, this trade off is no longer working in our favour.\nMaintaining the denormalised data is now more complex than generating queries against normalised data.\nWe are finding that some reported bugs are difficult to resolve due to the complex nature of resolving denormalised data.\nThere are also more sophisticated relationship patterns, such as [ordered relationships](https://github.com/keystonejs/keystone/issues/313), which are too difficult to implement in the current schema.\n\n## The solution\n\nTo address these problems at their core we have changed our data schema to be normalised and to eliminate the duplicated data.\nThis means that our query generation code has become more complex, but this trade off gains us a number of benefits:\n\n1. Eliminates duplicated data in the database.\n2. Uses a more conventional database schema design, particularly for `PostgreSQL`.\n3. More robust query generation.\n4. More extensible relationship patterns.\n\n### No more duplicated data\n\nEliminating duplicated data removes the risk of the data getting out of sync, and also simplified all of our `create`, `update`, and `delete` operations.\n\n### Conventional database schema\n\nThe new database schema matches much more closely with the schema a database engineer would design if they were building this schema by hand.\n\n### More robust queries\n\nAs part of this change we have introduced a much more comprehensive set of tests, which push the graphQL API to its limit.\nThese additional tests allowed us to find and fix a number of corner case bugs from the initial implementation.\n\n### More extensible relationships\n\nThe internal representation of relationships within Keystone is now much more sophisticated.\nThis will allow us to extend the kind of modelling that Keystone provides to include things like ordered relationships.\n\n## Updating your database\n\nIn order to take advantage of these improvements you will need to make some changes to your database.\nIn some instances this will simply involve removing tables or columns which are no longer required.\nIn other cases you will need to rename some tables or columns and possibly move data from one table to another.\n\nTo assist with this process we have written a [Schema Upgrade Guide](/docs/guides/relationship-migration.md), which will take you through the steps to safely transition your database.\n\n## Summary\n\nThe new Keystone data schema will simplify and improve the storage of your crucial system data, and will unlock new functionality.\nWe appreciate that making changes to your production database can be a daunting task, but we hope to make this process as smooth as possible.\nWe are looking forward to building on these changes to provide an even more powerful Keystone in the future ðŸš€\n"}},"__N_SSG":true}