{"pageProps":{"markdownPost":{"name":null,"url":null,"content":"---\nid: test-renderer\ntitle: Test Renderer\npermalink: docs/test-renderer.html\nlayout: docs\ncategory: Reference\n---\n\n**Importing**\n\n```javascript\nimport TestRenderer from 'react-test-renderer'; // ES6\nconst TestRenderer = require('react-test-renderer'); // ES5 with npm\n```\n\n## Overview {#overview}\n\nThis package provides a React renderer that can be used to render React components to pure JavaScript objects, without depending on the DOM or a native mobile environment.\n\nEssentially, this package makes it easy to grab a snapshot of the platform view hierarchy (similar to a DOM tree) rendered by a React DOM or React Native component without using a browser or [jsdom](https://github.com/tmpvar/jsdom).\n\nExample:\n\n```javascript\nimport TestRenderer from 'react-test-renderer';\n\nfunction Link(props) {\n  return <a href={props.page}>{props.children}</a>;\n}\n\nconst testRenderer = TestRenderer.create(\n  <Link page=\"https://www.facebook.com/\">Facebook</Link>\n);\n\nconsole.log(testRenderer.toJSON());\n// { type: 'a',\n//   props: { href: 'https://www.facebook.com/' },\n//   children: [ 'Facebook' ] }\n```\n\nYou can use Jest's snapshot testing feature to automatically save a copy of the JSON tree to a file and check in your tests that it hasn't changed: [Learn more about it](https://jestjs.io/docs/en/snapshot-testing).\n\nYou can also traverse the output to find specific nodes and make assertions about them.\n\n```javascript\nimport TestRenderer from 'react-test-renderer';\n\nfunction MyComponent() {\n  return (\n    <div>\n      <SubComponent foo=\"bar\" />\n      <p className=\"my\">Hello</p>\n    </div>\n  )\n}\n\nfunction SubComponent() {\n  return (\n    <p className=\"sub\">Sub</p>\n  );\n}\n\nconst testRenderer = TestRenderer.create(<MyComponent />);\nconst testInstance = testRenderer.root;\n\nexpect(testInstance.findByType(SubComponent).props.foo).toBe('bar');\nexpect(testInstance.findByProps({className: \"sub\"}).children).toEqual(['Sub']);\n```\n\n### TestRenderer {#testrenderer}\n\n* [`TestRenderer.create()`](#testrenderercreate)\n* [`TestRenderer.act()`](#testrendereract)\n\n### TestRenderer instance {#testrenderer-instance}\n\n* [`testRenderer.toJSON()`](#testrenderertojson)\n* [`testRenderer.toTree()`](#testrenderertotree)\n* [`testRenderer.update()`](#testrendererupdate)\n* [`testRenderer.unmount()`](#testrendererunmount)\n* [`testRenderer.getInstance()`](#testrenderergetinstance)\n* [`testRenderer.root`](#testrendererroot)\n\n### TestInstance {#testinstance}\n\n* [`testInstance.find()`](#testinstancefind)\n* [`testInstance.findByType()`](#testinstancefindbytype)\n* [`testInstance.findByProps()`](#testinstancefindbyprops)\n* [`testInstance.findAll()`](#testinstancefindall)\n* [`testInstance.findAllByType()`](#testinstancefindallbytype)\n* [`testInstance.findAllByProps()`](#testinstancefindallbyprops)\n* [`testInstance.instance`](#testinstanceinstance)\n* [`testInstance.type`](#testinstancetype)\n* [`testInstance.props`](#testinstanceprops)\n* [`testInstance.parent`](#testinstanceparent)\n* [`testInstance.children`](#testinstancechildren)\n\n## Reference {#reference}\n\n### `TestRenderer.create()` {#testrenderercreate}\n\n```javascript\nTestRenderer.create(element, options);\n```\n\nCreate a `TestRenderer` instance with the passed React element. It doesn't use the real DOM, but it still fully renders the component tree into memory so you can make assertions about it. Returns a [TestRenderer instance](#testrenderer-instance).\n\n### `TestRenderer.act()` {#testrendereract}\n\n```javascript\nTestRenderer.act(callback);\n```\n\nSimilar to the [`act()` helper from `react-dom/test-utils`](/docs/test-utils.html#act), `TestRenderer.act` prepares a component for assertions. Use this version of `act()` to wrap calls to `TestRenderer.create` and `testRenderer.update`.\n\n```javascript\nimport {create, act} from 'react-test-renderer';\nimport App from './app.js'; // The component being tested\n\n// render the component\nlet root; \nact(() => {\n  root = create(<App value={1}/>)\n});\n\n// make assertions on root \nexpect(root.toJSON()).toMatchSnapshot();\n\n// update with some different props\nact(() => {\n  root.update(<App value={2}/>);\n})\n\n// make assertions on root \nexpect(root.toJSON()).toMatchSnapshot();\n```\n\n### `testRenderer.toJSON()` {#testrenderertojson}\n\n```javascript\ntestRenderer.toJSON()\n```\n\nReturn an object representing the rendered tree. This tree only contains the platform-specific nodes like `<div>` or `<View>` and their props, but doesn't contain any user-written components. This is handy for [snapshot testing](https://facebook.github.io/jest/docs/en/snapshot-testing.html#snapshot-testing-with-jest).\n\n### `testRenderer.toTree()` {#testrenderertotree}\n\n```javascript\ntestRenderer.toTree()\n```\n\nReturn an object representing the rendered tree. The representation is more detailed than the one provided by `toJSON()`, and includes the user-written components. You probably don't need this method unless you're writing your own assertion library on top of the test renderer.\n\n### `testRenderer.update()` {#testrendererupdate}\n\n```javascript\ntestRenderer.update(element)\n```\n\nRe-render the in-memory tree with a new root element. This simulates a React update at the root. If the new element has the same type and key as the previous element, the tree will be updated; otherwise, it will re-mount a new tree.\n\n### `testRenderer.unmount()` {#testrendererunmount}\n\n```javascript\ntestRenderer.unmount()\n```\n\nUnmount the in-memory tree, triggering the appropriate lifecycle events.\n\n### `testRenderer.getInstance()` {#testrenderergetinstance}\n\n```javascript\ntestRenderer.getInstance()\n```\n\nReturn the instance corresponding to the root element, if available. This will not work if the root element is a function component because they don't have instances.\n\n### `testRenderer.root` {#testrendererroot}\n\n```javascript\ntestRenderer.root\n```\n\nReturns the root \"test instance\" object that is useful for making assertions about specific nodes in the tree. You can use it to find other \"test instances\" deeper below.\n\n### `testInstance.find()` {#testinstancefind}\n\n```javascript\ntestInstance.find(test)\n```\n\nFind a single descendant test instance for which `test(testInstance)` returns `true`. If `test(testInstance)` does not return `true` for exactly one test instance, it will throw an error.\n\n### `testInstance.findByType()` {#testinstancefindbytype}\n\n```javascript\ntestInstance.findByType(type)\n```\n\nFind a single descendant test instance with the provided `type`. If there is not exactly one test instance with the provided `type`, it will throw an error.\n\n### `testInstance.findByProps()` {#testinstancefindbyprops}\n\n```javascript\ntestInstance.findByProps(props)\n```\n\nFind a single descendant test instance with the provided `props`. If there is not exactly one test instance with the provided `props`, it will throw an error.\n\n### `testInstance.findAll()` {#testinstancefindall}\n\n```javascript\ntestInstance.findAll(test)\n```\n\nFind all descendant test instances for which `test(testInstance)` returns `true`.\n\n### `testInstance.findAllByType()` {#testinstancefindallbytype}\n\n```javascript\ntestInstance.findAllByType(type)\n```\n\nFind all descendant test instances with the provided `type`.\n\n### `testInstance.findAllByProps()` {#testinstancefindallbyprops}\n\n```javascript\ntestInstance.findAllByProps(props)\n```\n\nFind all descendant test instances with the provided `props`.\n\n### `testInstance.instance` {#testinstanceinstance}\n\n```javascript\ntestInstance.instance\n```\n\nThe component instance corresponding to this test instance. It is only available for class components, as function components don't have instances. It matches the `this` value inside the given component.\n\n### `testInstance.type` {#testinstancetype}\n\n```javascript\ntestInstance.type\n```\n\nThe component type corresponding to this test instance. For example, a `<Button />` component has a type of `Button`.\n\n### `testInstance.props` {#testinstanceprops}\n\n```javascript\ntestInstance.props\n```\n\nThe props corresponding to this test instance. For example, a `<Button size=\"small\" />` component has `{size: 'small'}` as props.\n\n### `testInstance.parent` {#testinstanceparent}\n\n```javascript\ntestInstance.parent\n```\n\nThe parent test instance of this test instance.\n\n### `testInstance.children` {#testinstancechildren}\n\n```javascript\ntestInstance.children\n```\n\nThe children test instances of this test instance.\n\n## Ideas {#ideas}\n\nYou can pass `createNodeMock` function to `TestRenderer.create` as the option, which allows for custom mock refs.\n`createNodeMock` accepts the current element and should return a mock ref object.\nThis is useful when you test a component that relies on refs.\n\n```javascript\nimport TestRenderer from 'react-test-renderer';\n\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.input = null;\n  }\n  componentDidMount() {\n    this.input.focus();\n  }\n  render() {\n    return <input type=\"text\" ref={el => this.input = el} />\n  }\n}\n\nlet focused = false;\nTestRenderer.create(\n  <MyComponent />,\n  {\n    createNodeMock: (element) => {\n      if (element.type === 'input') {\n        // mock a focus function\n        return {\n          focus: () => {\n            focused = true;\n          }\n        };\n      }\n      return null;\n    }\n  }\n);\nexpect(focused).toBe(true);\n```\n"}},"__N_SSG":true}