{"pageProps":{"markdownPost":{"name":null,"url":null,"content":"---\ntitle: Advanced topics on caching\nsidebar_title: Advanced topics\n---\n\nThis article describes special cases and considerations when using the Apollo Client cache.\n\n## Bypassing the cache\n\nSometimes you _shouldn't_ use the cache for a particular GraphQL operation. For example, a query's response might be a token that's only used once. In cases like this, use [the `no-cache` fetch policy](../data/queries/#setting-a-fetch-policy):\n\n```js\nconst { loading, error, data } = useQuery(GET_DOGS, {\n  fetchPolicy: \"no-cache\" // highlight-line\n});\n```\n\nOperations that use this fetch policy don't write their result to the cache, and they also don't check the cache for data before sending a request to your server.\n\n## Rerunning queries after a mutation\n\nIn certain cases, writing an `update` function to [update the cache after a mutation](../data/mutations/#updating-the-cache-after-a-mutation) can be complex, or even impossible if the mutation doesn't return modified fields.\n\nIn these cases, you can provide a `refetchQueries` option to the `useMutation` hook to automatically rerun certain queries after the mutation completes.\n\n> Note that although `refetchQueries` can be faster to implement than an `update` function, it also requires additional network requests that are usually undesirable. For more information, see [this blog post](https://www.apollographql.com/blog/when-to-use-refetch-queries-in-apollo-client/).\n\nHere's an example of using `refetchQueries` to execute a query that's specified inline:\n\n```javascript\nuseMutation(\n  // ... Mutation definition ...\n\n  // Mutation options\n  {\n  refetchQueries: [{\n    query: gql`\n      query UpdateCache($repoName: String!) {\n        entry(repoFullName: $repoName) {\n          id\n          comments {\n            postedBy {\n              login\n              html_url\n            }\n            createdAt\n            content\n          }\n        }\n      }\n    `,\n    variables: { repoName: 'apollographql/apollo-client' },\n  }],\n});\n```\n\nThe `refetchQueries` option is an array where each element is one of the following:\n\n* An object with a `query` field that specifies the query to execute, along with a `variables` field if applicable (shown above)\n* The name of a query you've previously executed, as a string (e.g., `GetComments`)\n  * _Queries you list by name are executed with their most recently provided set of variables._\n\nYou can also import and provide queries that are defined in other components to make sure those components are updated:\n\n```javascript\nimport RepoCommentsQuery from '../queries/RepoCommentsQuery';\n\nmutate({\n  //... insert comment mutation\n  refetchQueries: [{\n    query: RepoCommentsQuery,\n    variables: { repoFullName: 'apollographql/apollo-client' },\n  }],\n})\n```\n\n## Incremental loading: `fetchMore`\n\n`fetchMore` can be used to update the result of a query based on the data returned by another query. Most often, it is used to handle infinite-scroll pagination or other situations where you are loading more data when you already have some.\n\nIn our GitHunt example, we have a paginated feed that displays a list of GitHub repositories. When we hit the \"Load More\" button, we don't want Apollo Client to throw away the repository information it has already loaded. Instead, it should just append the newly loaded repositories to the list that Apollo Client already has in the store. With this update, our UI component should re-render and show us all of the available repositories.\n\nLet's see how to do that with the `fetchMore` method on a query:\n\n```javascript\nconst FEED_QUERY = gql`\n  query Feed($type: FeedType!, $offset: Int, $limit: Int) {\n    currentUser {\n      login\n    }\n    feed(type: $type, offset: $offset, limit: $limit) {\n      id\n      # ...\n    }\n  }\n`;\n\nconst FeedWithData = ({ match }) => (\n  <Query\n    query={FEED_QUERY}\n    variables={{\n      type: match.params.type.toUpperCase() || \"TOP\",\n      offset: 0,\n      limit: 10\n    }}\n    fetchPolicy=\"cache-and-network\"\n  >\n    {({ data, fetchMore }) => (\n      <Feed\n        entries={data.feed || []}\n        onLoadMore={() =>\n          fetchMore({\n            variables: {\n              offset: data.feed.length\n            },\n            updateQuery: (prev, { fetchMoreResult }) => {\n              if (!fetchMoreResult) return prev;\n              return Object.assign({}, prev, {\n                feed: [...prev.feed, ...fetchMoreResult.feed]\n              });\n            }\n          })\n        }\n      />\n    )}\n  </Query>\n);\n```\n\n\nThe `fetchMore` method takes a map of `variables` to be sent with the new query. Here, we're setting the offset to `feed.length` so that we fetch items that aren't already displayed on the feed. This variable map is merged with the one that's been specified for the query associated with the component. This means that other variables, e.g. the `limit` variable, will have the same value as they do within the component query.\n\nIt can also take a `query` named argument, which can be a GraphQL document containing a query that will be fetched in order to fetch more information; we refer to this as the `fetchMore` query. By default, the `fetchMore` query is the query associated with the container, in this case the `FEED_QUERY`.\n\nWhen we call `fetchMore`, Apollo Client will fire the `fetchMore` query and use the logic in the `updateQuery` option to incorporate that into the original result. The named argument `updateQuery` should be a function that takes the previous result of the query associated with your component (i.e. `FEED_QUERY` in this case) and the information returned by the `fetchMore` query and return a combination of the two.\n\nHere, the `fetchMore` query is the same as the query associated with the component. Our `updateQuery` takes the new feed items returned and just appends them onto the feed items that we'd asked for previously. With this, the UI will update and the feed will contain the next page of items!\n\nAlthough `fetchMore` is often used for pagination, there are many other cases in which it is applicable. For example, suppose you have a list of items (say, a collaborative todo list) and you have a way to fetch items that have been updated after a certain time. Then, you don't have to refetch the whole todo list to get updates: you can just incorporate the newly added items with `fetchMore`, as long as your `updateQuery` function correctly merges the new results.\n\n## The `@connection` directive\n\nFundamentally, paginated queries are the same as any other query with the exception that calls to `fetchMore` update the same cache key. Since these queries are cached by both the initial query and their parameters, a problem arises when later retrieving or updating paginated queries in the cache. We don’t care about pagination arguments such as limits, offsets, or cursors outside of the need to `fetchMore`, nor do we want to provide them simply for accessing cached data.\n\nTo solve this Apollo Client 1.6 introduced the `@connection` directive to specify a custom store key for results. A connection allows us to set the cache key for a field and to filter which arguments actually alter the query.\n\nTo use the `@connection` directive, simply add the directive to the segment of the query you want a custom store key for and provide the `key` parameter to specify the store key. In addition to the `key` parameter, you can also include the optional `filter` parameter, which takes an array of query argument names to include in the generated custom store key.\n\n```js\nconst query = gql`\n  query Feed($type: FeedType!, $offset: Int, $limit: Int) {\n    feed(type: $type, offset: $offset, limit: $limit) @connection(key: \"feed\", filter: [\"type\"]) {\n      ...FeedEntry\n    }\n  }\n`\n```\n\nWith the above query, even with multiple `fetchMore`s, the results of each feed update will always result in the `feed` key in the store being updated with the latest accumulated values. In this example, we also use the `@connection` directive's optional `filter` argument to include the `type` query argument in the store key, which results in multiple store values that accumulate queries from each type of feed.\n\nNow that we have a stable store key, we can easily use `writeQuery` to perform a store update, in this case clearing out the feed.\n\n```js\nclient.writeQuery({\n  query: gql`\n    query Feed($type: FeedType!) {\n      feed(type: $type) @connection(key: \"feed\", filter: [\"type\"]) {\n        id\n      }\n    }\n  `,\n  variables: {\n    type: \"top\",\n  },\n  data: {\n    feed: [],\n  },\n});\n```\n\nNote that because we are only using the `type` argument in the store key, we don't have to provide `offset` or `limit`.\n\n## Cache redirects using field policy `read` functions\n\n> ⚠️ **Note:** Apollo Client >= 3.0 no longer supports the `ApolloClient` `cacheRedirects` constructor option. Equivalent `cacheRedirects` functionality can now be handled with field policy `read` functions, and is explained below.\n\nIn some cases, a query requests data that already exists in the cache under a different reference. A very common example of this is when your UI has a list view and a detail view that both use the same data. The list view might run the following query:\n\n```graphql\nquery Books {\n  books {\n    id\n    title\n    abstract\n  }\n}\n```\n\nWhen a specific book is selected, the detail view displays an individual item using this query:\n\n```graphql\nquery Book($id: ID!) {\n  book(id: $id) {\n    id\n    title\n    abstract\n  }\n}\n```\n\nWe know that the data is most likely already in the client cache, but because it was requested with a different query, Apollo Client doesn't know that. To tell Apollo Client where to look for the existing `book` data, we can define a field policy `read` function for the `book` field:\n\n```js\nimport { ApolloClient, InMemoryCache } from '@apollo/client';\n\nconst client = new ApolloClient({\n  cache: new InMemoryCache({\n    typePolicies: {\n      Query: {\n        fields: {\n          book(_, { args, toReference }) {\n            return toReference({\n              __typename: 'Book',\n              id: args.id,\n            });\n          }\n        }\n      }\n    }\n  }\n});\n```\n\nNow whenever a query is run that includes a `book` field, the `read` function above will be executed, and return a reference that points to the book entity that was already created in the cache when the `Books` list view query ran. Apollo Client will use the reference returned by the `read` function to look up the item in its cache. `toReference` is a helper utility that is passed into `read` functions as part of the second parameter options object, and is used to generate an entity reference based on its `__typename` and `id`.\n\n> ⚠️ **Note:** For the above to work properly, the data returned by the list query has to include all of the data the specific detail query needs. If the specific detail query fetches a field that the list query doesn't return, Apollo Client will consider the cache hit to be incomplete, and will attempt to fetch the full data set over the network (if network requests are enabled).\n\n## Resetting the store\n\nSometimes, you may want to reset the store entirely, such as [when a user logs out](../networking/authentication/#reset-store-on-logout). To accomplish this, use `client.resetStore` to clear out your Apollo cache. Since `client.resetStore` also refetches any of your active queries for you, it is asynchronous.\n\n```js\nexport default withApollo(graphql(PROFILE_QUERY, {\n  props: ({ data: { loading, currentUser }, ownProps: { client }}) => ({\n    loading,\n    currentUser,\n    resetOnLogout: async () => client.resetStore(),\n  }),\n})(Profile));\n```\n\nTo register a callback function to be executed after the store has been reset, call `client.onResetStore` and pass in your callback. If you would like to register multiple callbacks, simply call `client.onResetStore` again. All of your callbacks will be pushed into an array and executed concurrently.\n\nIn this example, we're using `client.onResetStore` to write default values to the cache. This is useful when using Apollo Client's [local state management](../local-state/local-state-management/) features and calling `client.resetStore` anywhere in your application.\n\n```js\nimport { ApolloClient, InMemoryCache } from '@apollo/client';\nimport { withClientState } from 'apollo-link-state';\n\nimport { resolvers, defaults } from './resolvers';\n\nconst cache = new InMemoryCache();\nconst stateLink = withClientState({ cache, resolvers, defaults });\n\nconst client = new ApolloClient({\n  cache,\n  link: stateLink,\n});\n\nclient.onResetStore(stateLink.writeDefaults);\n```\n\nYou can also call `client.onResetStore` from your React components. This can be useful if you would like to force your UI to rerender after the store has been reset.\n\nIf you would like to unsubscribe your callbacks from resetStore, use the return value of `client.onResetStore` for your unsubscribe function.\n\n```js\nimport { withApollo } from \"@apollo/react-hoc\";\n\nexport class Foo extends Component {\n  constructor(props) {\n    super(props);\n    this.unsubscribe = props.client.onResetStore(\n      () => this.setState({ reset: false })\n    );\n    this.state = { reset: false };\n  }\n  componentDidUnmount() {\n    this.unsubscribe();\n  }\n  render() {\n    return this.state.reset ? <div /> : <span />\n  }\n}\n\nexport default withApollo(Foo);\n```\n\nIf you want to clear the store but don't want to refetch active queries, use\n`client.clearStore()` instead of `client.resetStore()`.\n\n## Cache persistence\n\nIf you would like to persist and rehydrate your Apollo Cache from a storage provider like `AsyncStorage` or `localStorage`, you can use [`apollo3-cache-persist`](https://github.com/apollographql/apollo-cache-persist). `apollo3-cache-persist` works with all Apollo caches, including `InMemoryCache` & `Hermes`, and a variety of different [storage providers](https://github.com/apollographql/apollo-cache-persist#storage-providers).\n\nTo get started, simply pass your Apollo Cache and a storage provider to `persistCache`. By default, the contents of your Apollo Cache will be immediately restored asynchronously, and persisted upon every write to the cache with a short configurable debounce interval.\n\n> Note: The `persistCache` method is async and returns a `Promise`.\n\n```js\nimport { AsyncStorage } from 'react-native';\nimport { InMemoryCache } from '@apollo/client';\nimport { persistCache } from 'apollo3-cache-persist';\n\nconst cache = new InMemoryCache();\n\npersistCache({\n  cache,\n  storage: AsyncStorage,\n}).then(() => {\n  // Continue setting up Apollo as usual.\n})\n```\n\nFor more advanced usage, such as persisting the cache when the app is in the background, and additional configuration options, please check the [README of `apollo3-cache-persist`](https://github.com/apollographql/apollo-cache-persist).\n"}},"__N_SSG":true}