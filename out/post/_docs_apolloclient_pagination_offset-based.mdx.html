<!DOCTYPE html><html lang="vi"><head><meta charset="utf-8"/><meta property="og:type" content="website"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicon-16x16.png?h=cf681ecd5bbf6d03e3056673d0122646"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicon-32x32.png?h=dada6ed6c75053e6f84520a87241cd23"/><link rel="icon" type="image/png" sizes="180x180" href="/assets/img/apple-icon-180x180.png?h=b5b7d59e89a4d05d1aca1c00dfe1b70f"/><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/android-icon-192x192.png?h=033de9a23d4cfa21fd3383f727564736"/><link rel="icon" type="image/png" sizes="310x310" href="/assets/img/ms-icon-310x310.png?h=f9285fe98206007e11710305c82d9ea2"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/4.5.3/united/bootstrap.min.css"/><link rel="stylesheet" href="/assets/css/styles.min.css?h=69c29b29303563e0ebbd0e0e69162409"/><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2f26bb9842d84a608fa3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2f26bb9842d84a608fa3.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-71dd292baef5e0c3d163.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9116e7bff2bfccdffa19.js" as="script"/><link rel="preload" href="/_next/static/chunks/8638dade453fc283329f8b8dee6f6817b55b3944.9475e511f211dbecfbed.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-de7ed68c6e8649dd556c.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/post/%5Bpath%5D-98a2b37c69fbc1053078.js" as="script"/></head><body><header><img data-aos="fade-down" class="img-wave" src="/assets/img/wave(1).svg" alt="Nền"/><nav class="navbar navbar-light navbar-expand-md navigation-clean py-2"><div class="container"><img class="mr-3" src="/assets/img/favicon-32x32.png?h=dada6ed6c75053e6f84520a87241cd23" alt="logo" width="32" height="32"/><a class="navbar-brand p-0" href="/"><h6 class="text-uppercase m-0 p-0">loa loa team</h6> </a><button data-toggle="collapse" class="navbar-toggler" data-target="#navcol-1"><span class="sr-only">Toggle navigation</span><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navcol-1"><ul class="nav navbar-nav ml-auto"><li class="nav-item"><a class="nav-link" href="/">Trang chủ</a></li><li class="nav-item"><a class="nav-link" href="/projects">Dự án</a></li><li class="nav-item"><a class="nav-link" href="/docs">Tài liệu</a></li><li class="nav-item"><a class="nav-link" href="/blogs">Bài viết</a></li></ul></div></div></nav></header><div id="__next"><section class="container"><div><hr>
<p>title: 'Offset-based pagination'
sidebar_title: 'Offset-based'</p>
<hr>
<blockquote>
<p>We recommend reading <a href="./core-api">Core pagination API</a> before learning about considerations specific to offset-based pagination.</p>
</blockquote>
<p>Offset-based pagination works well for immutable lists, or lists whose element positions are not expected to change, since moving or removing elements could alter the offsets of the elements in the list, sometimes causing elements to be skipped or duplicated if the list is modified on the server between page requests.</p>
<p>Although offset-based pagination has these shortcomings, it is a common pattern found in many applications, in part because it is straightforward to implement on the backend. In SQL, for example, numbered pages can easily be generated by using <a href="https://www.postgresql.org/docs/8.2/static/queries-limit.html">OFFSET and LIMIT</a>.</p>
<h2>The <code>offsetLimitPagination</code> helper</h2>
<p>Common pagination strategies can be abstracted away into helper functions, such as the <code>offsetLimitPagination</code> function that <code>@apollo/client/utilities</code> provides:</p>
<pre><code class="language-js">import { offsetLimitPagination } from &quot;@apollo/client/utilities&quot;

const cache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        feed: offsetLimitPagination([&quot;type&quot;]),
      },
    },
  },
});
</code></pre>
<p>The <code>[&quot;type&quot;]</code> argument here specifies the <code>keyArgs</code> to be used for this field policy. By default, <code>offsetLimitPagination</code> uses <code>keyArgs: false</code>.</p>
<p>If you set the field policy above for <code>Query.feed</code>, then you can use <code>fetchMore</code> with <code>useQuery</code> like so:</p>
<pre><code class="language-jsx">const FeedData({ type = &quot;PUBLIC&quot; }) {
  const { loading, data, fetchMore } = useQuery(FEED_QUERY, {
    variables: {
      type: type.toUpperCase(),
      offset: 0,
      limit: 10
    },
  });

  // If you want your component to rerender with loading:true whenever
  // fetchMore is called, add notifyOnNetworkStatusChange:true to the
  // options you pass to useQuery above.
  if (loading) return &lt;Loading/&gt;;

  return (
    &lt;Feed
      entries={data.feed || []}
      onLoadMore={() =&gt; fetchMore({
        variables: {
          offset: data.feed.length
        },
      })}
    /&gt;
  );
}
</code></pre>
<p>By default, <code>fetchMore</code> uses the original <code>query</code> and <code>variables</code>, so we only need to pass the variable that is changing: the <code>offset</code>. Once the new data is returned from the server, it will be automatically merged with any existing <code>Query.feed</code> data in the cache, which will cause <code>useQuery</code> to rerender with the expanded list of data.</p>
<p>This style of <code>fetchMore</code> usage assumes you want your component to receive the entire available list each time it renders, containing data from all pages received so far. This is a <a href="./core-api/#non-paginated-read-functions">non-paginated <code>read</code> function</a>.</p>
<p>If you are using a <code>Query.feed</code> field policy containing a <code>read</code> function that uses <code>args.offset</code> and <code>args.limit</code> to return a single page of data, the code above will still work, but you may be surprised that your component does not automatically rerender with additional data (beyond the first page) after <code>fetchMore</code> finishes. This happens because the original <code>variables: { offset: 0, limit: 10 }</code> are still in effect, and the first 10 items were not changed by the <code>fetchMore</code> call, so your <code>read</code> function returns the same page as before.</p>
<p>Before you can fix this problem, you first need to think about the behavior that you want. Should your component continue displaying only the first page, or should it now display the page we just received, or should it display the entire list of known data? Regardless of which option you prefer, these alternatives all boil down to the <code>variables</code> you pass to <code>useQuery</code>, which must change if you want your component to render different data.</p>
<p>For example, to display all the data received so far, you could modify the previous example as follows:</p>
<pre><code class="language-jsx">const FeedData({ type = &quot;PUBLIC&quot; }) {
  const [limit, setLimit] = useState(10);
  const { loading, data, fetchMore } = useQuery(FEED_QUERY, {
    variables: {
      type: type.toUpperCase(),
      offset: 0,
      limit,
    },
  });

  if (loading) return &lt;Loading/&gt;;

  return (
    &lt;Feed
      entries={data.feed || []}
      onLoadMore={() =&gt; {
        const currentLength = data.feed.length;
        fetchMore({
          variables: {
            offset: currentLength,
            limit: 10,
          },
        }).then(fetchMoreResult =&gt; {
          // Update variables.limit for the original query to include
          // the newly added feed items.
          setLimit(currentLength + fetchMoreResult.data.feed.length);
        });
      }
    /&gt;
  );
}
</code></pre>
<p>This code uses a React <code>useState</code> Hook to store the current <code>limit</code> value, which it updates by calling <code>setLimit</code> in a callback attached to the <code>Promise</code> returned by <code>fetchMore</code>.</p>
<p>You could store <code>offset</code> in a React <code>useState</code> Hook as well, if you need the <code>offset</code> to change. Exactly when and how these <code>variables</code> change is up to your component, and may not always be the result of calling <code>fetchMore</code>, so it makes sense to use React component state to store these variable values.</p>
<blockquote>
<p>If you are not using React and <code>useQuery</code>, the <code>ObservableQuery</code> object returned by <code>client.watchQuery</code> has a method called <code>setVariables</code> that you can call to update the original variables.</p>
</blockquote>
<p>Because <code>fetchMore</code> requires some extra work to update the original variables if you're using a <code>read</code> function that is sensitive to those variables (the second kind of <code>read</code> function), it's fair to say <code>fetchMore</code> encourages the first kind of <code>read</code> function, which simply returns all available data.</p>
<p>However, now that you understand your options, there's nothing wrong with moving read-time pagination logic out of your application code and into your field <code>read</code> functions. Both kinds of <code>read</code> functions have their uses, and both can be made to work with <code>fetchMore</code>.</p>
</div></section></div><footer class="footer-clean"><div class="container"><div class="row justify-content-center"><div class="col-sm-4 col-md-3 item"><h3 class="text-primary">Dịch vụ</h3><ul class="list-unstyled"><li><a class="text-body" href="#">Thiết kế website</a></li><li><a class="text-body" href="#">Phát triển phần mềm</a></li><li><a class="text-body" href="#">Hosting</a></li></ul></div><div class="col-sm-4 col-md-3 item"><h3 class="text-primary">Phát triển bởi</h3><ul class="list-inline d-inline"><li class="list-inline-item d-inline-block">Sinh viên trường ĐH Bách Khoa Đà Nẵng.</li></ul><h3 class="text-primary">Công ty</h3><ul class="list-unstyled"><li>Công ty TNHH Công Nghệ Điện Tử Quảng Đà.</li><li>Mã số thuế: 4001202704.</li><li>Địa chỉ: Thôn 2, Xã Bình Đào, Huyện Thăng Bình, Tỉnh Quảng Nam.<br/></li><li></li></ul></div><div class="col-sm-4 col-md-3 item"><h3 class="text-primary">Liên hệ</h3><ul class="list-unstyled"><li>Leader: Trần Ngọc Huy</li><li>Điện thoại/Zalo: 0332813077</li><li>Địa chỉ: 54 Nguyễn Lương Bằng, Liên Chiểu, Đà Nẵng.</li><li></li></ul><img class="w-100" src="/assets/img/zalo.jpg?h=614debe3b6ec66917ebd818aa1c50b6e" loading="lazy" alt="Zalo"/></div></div></div><img src="/assets/img/wave(2).svg?h=5ad7ab1ad1557422fec002e92b1ae54b" alt="Nền"/></footer><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"markdownPost":{"name":null,"url":null,"content":"---\ntitle: 'Offset-based pagination'\nsidebar_title: 'Offset-based'\n---\n\n\u003e We recommend reading [Core pagination API](./core-api) before learning about considerations specific to offset-based pagination.\n\nOffset-based pagination works well for immutable lists, or lists whose element positions are not expected to change, since moving or removing elements could alter the offsets of the elements in the list, sometimes causing elements to be skipped or duplicated if the list is modified on the server between page requests.\n\nAlthough offset-based pagination has these shortcomings, it is a common pattern found in many applications, in part because it is straightforward to implement on the backend. In SQL, for example, numbered pages can easily be generated by using [OFFSET and LIMIT](https://www.postgresql.org/docs/8.2/static/queries-limit.html).\n\n## The `offsetLimitPagination` helper\n\nCommon pagination strategies can be abstracted away into helper functions, such as the `offsetLimitPagination` function that `@apollo/client/utilities` provides:\n\n```js\nimport { offsetLimitPagination } from \"@apollo/client/utilities\"\n\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Query: {\n      fields: {\n        feed: offsetLimitPagination([\"type\"]),\n      },\n    },\n  },\n});\n```\n\nThe `[\"type\"]` argument here specifies the `keyArgs` to be used for this field policy. By default, `offsetLimitPagination` uses `keyArgs: false`.\n\nIf you set the field policy above for `Query.feed`, then you can use `fetchMore` with `useQuery` like so:\n\n```jsx\nconst FeedData({ type = \"PUBLIC\" }) {\n  const { loading, data, fetchMore } = useQuery(FEED_QUERY, {\n    variables: {\n      type: type.toUpperCase(),\n      offset: 0,\n      limit: 10\n    },\n  });\n\n  // If you want your component to rerender with loading:true whenever\n  // fetchMore is called, add notifyOnNetworkStatusChange:true to the\n  // options you pass to useQuery above.\n  if (loading) return \u003cLoading/\u003e;\n\n  return (\n    \u003cFeed\n      entries={data.feed || []}\n      onLoadMore={() =\u003e fetchMore({\n        variables: {\n          offset: data.feed.length\n        },\n      })}\n    /\u003e\n  );\n}\n```\n\nBy default, `fetchMore` uses the original `query` and `variables`, so we only need to pass the variable that is changing: the `offset`. Once the new data is returned from the server, it will be automatically merged with any existing `Query.feed` data in the cache, which will cause `useQuery` to rerender with the expanded list of data.\n\nThis style of `fetchMore` usage assumes you want your component to receive the entire available list each time it renders, containing data from all pages received so far. This is a [non-paginated `read` function](./core-api/#non-paginated-read-functions).\n\nIf you are using a `Query.feed` field policy containing a `read` function that uses `args.offset` and `args.limit` to return a single page of data, the code above will still work, but you may be surprised that your component does not automatically rerender with additional data (beyond the first page) after `fetchMore` finishes. This happens because the original `variables: { offset: 0, limit: 10 }` are still in effect, and the first 10 items were not changed by the `fetchMore` call, so your `read` function returns the same page as before.\n\nBefore you can fix this problem, you first need to think about the behavior that you want. Should your component continue displaying only the first page, or should it now display the page we just received, or should it display the entire list of known data? Regardless of which option you prefer, these alternatives all boil down to the `variables` you pass to `useQuery`, which must change if you want your component to render different data.\n\nFor example, to display all the data received so far, you could modify the previous example as follows:\n\n```jsx\nconst FeedData({ type = \"PUBLIC\" }) {\n  const [limit, setLimit] = useState(10);\n  const { loading, data, fetchMore } = useQuery(FEED_QUERY, {\n    variables: {\n      type: type.toUpperCase(),\n      offset: 0,\n      limit,\n    },\n  });\n\n  if (loading) return \u003cLoading/\u003e;\n\n  return (\n    \u003cFeed\n      entries={data.feed || []}\n      onLoadMore={() =\u003e {\n        const currentLength = data.feed.length;\n        fetchMore({\n          variables: {\n            offset: currentLength,\n            limit: 10,\n          },\n        }).then(fetchMoreResult =\u003e {\n          // Update variables.limit for the original query to include\n          // the newly added feed items.\n          setLimit(currentLength + fetchMoreResult.data.feed.length);\n        });\n      }\n    /\u003e\n  );\n}\n```\n\nThis code uses a React `useState` Hook to store the current `limit` value, which it updates by calling `setLimit` in a callback attached to the `Promise` returned by `fetchMore`.\n\nYou could store `offset` in a React `useState` Hook as well, if you need the `offset` to change. Exactly when and how these `variables` change is up to your component, and may not always be the result of calling `fetchMore`, so it makes sense to use React component state to store these variable values.\n\n\u003e If you are not using React and `useQuery`, the `ObservableQuery` object returned by `client.watchQuery` has a method called `setVariables` that you can call to update the original variables.\n\nBecause `fetchMore` requires some extra work to update the original variables if you're using a `read` function that is sensitive to those variables (the second kind of `read` function), it's fair to say `fetchMore` encourages the first kind of `read` function, which simply returns all available data.\n\nHowever, now that you understand your options, there's nothing wrong with moving read-time pagination logic out of your application code and into your field `read` functions. Both kinds of `read` functions have their uses, and both can be made to work with `fetchMore`.\n"}},"__N_SSG":true},"page":"/post/[path]","query":{"path":"_docs_apolloclient_pagination_offset-based.mdx"},"buildId":"IU2MQGFEli_aRg5UtGR53","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-4beebf4ac9054f0bf4e6.js"></script><script src="/_next/static/chunks/main-71dd292baef5e0c3d163.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9116e7bff2bfccdffa19.js" async=""></script><script src="/_next/static/chunks/8638dade453fc283329f8b8dee6f6817b55b3944.9475e511f211dbecfbed.js" async=""></script><script src="/_next/static/chunks/pages/_app-de7ed68c6e8649dd556c.js" async=""></script><script src="/_next/static/chunks/pages/post/%5Bpath%5D-98a2b37c69fbc1053078.js" async=""></script><script src="/_next/static/IU2MQGFEli_aRg5UtGR53/_buildManifest.js" async=""></script><script src="/_next/static/IU2MQGFEli_aRg5UtGR53/_ssgManifest.js" async=""></script></body></html>