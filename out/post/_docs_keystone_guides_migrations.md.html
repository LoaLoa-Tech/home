<!DOCTYPE html><html lang="vi"><head><meta charset="utf-8"/><meta property="og:type" content="website"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicon-16x16.png?h=cf681ecd5bbf6d03e3056673d0122646"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicon-32x32.png?h=dada6ed6c75053e6f84520a87241cd23"/><link rel="icon" type="image/png" sizes="180x180" href="/assets/img/apple-icon-180x180.png?h=b5b7d59e89a4d05d1aca1c00dfe1b70f"/><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/android-icon-192x192.png?h=033de9a23d4cfa21fd3383f727564736"/><link rel="icon" type="image/png" sizes="310x310" href="/assets/img/ms-icon-310x310.png?h=f9285fe98206007e11710305c82d9ea2"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/4.5.3/united/bootstrap.min.css"/><link rel="stylesheet" href="/assets/css/styles.min.css?h=69c29b29303563e0ebbd0e0e69162409"/><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2f26bb9842d84a608fa3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2f26bb9842d84a608fa3.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-71dd292baef5e0c3d163.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9116e7bff2bfccdffa19.js" as="script"/><link rel="preload" href="/_next/static/chunks/8638dade453fc283329f8b8dee6f6817b55b3944.9475e511f211dbecfbed.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-de7ed68c6e8649dd556c.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/post/%5Bpath%5D-98a2b37c69fbc1053078.js" as="script"/></head><body><header><img data-aos="fade-down" class="img-wave" src="/assets/img/wave(1).svg" alt="Nền"/><nav class="navbar navbar-light navbar-expand-md navigation-clean py-2"><div class="container"><img class="mr-3" src="/assets/img/favicon-32x32.png?h=dada6ed6c75053e6f84520a87241cd23" alt="logo" width="32" height="32"/><a class="navbar-brand p-0" href="/"><h6 class="text-uppercase m-0 p-0">loa loa team</h6> </a><button data-toggle="collapse" class="navbar-toggler" data-target="#navcol-1"><span class="sr-only">Toggle navigation</span><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navcol-1"><ul class="nav navbar-nav ml-auto"><li class="nav-item"><a class="nav-link" href="/">Trang chủ</a></li><li class="nav-item"><a class="nav-link" href="/projects">Dự án</a></li><li class="nav-item"><a class="nav-link" href="/docs">Tài liệu</a></li><li class="nav-item"><a class="nav-link" href="/blogs">Bài viết</a></li></ul></div></div></nav></header><div id="__next"><section class="container"><div><!--[meta]
section: guides
title: Migrations
subSection: advanced
[meta]-->
<h1>Migrations in Keystone</h1>
<p>As your app grows new features, you'll inevitably need to change some of your existing List definitions. When you do, you'll also need to migrate the data and schema in your database backend.</p>
<p><strong>Keystone can't automatically manage these migrations for you</strong> because it doesn't know what to do with the existing data. This guide will explain when and why you need database migrations and offer some basic solutions to get you started.</p>
<p>When you create a new List, depending on the adapter, Keystone will initialise a database table with columns for each of the fields defined in the List. Let's look at an example.</p>
<pre><code class="language-javascript">const { KnexAdapter } = require('@keystonejs/adapter-knex');

const keystone = new Keystone({
  adapter: new KnexAdapter(),
});

keystone.createList('ExampleList', {
  fields: {
    age: { type: Integer },
  },
});
</code></pre>
<p>Using the KnexAdapter if we create an <code>ExampleList</code> that contains an <code>Integer</code> field called <code>age</code> when we start Keystone for the first time it will generate a table with an <code>id</code> and <code>age</code> column:</p>
<table>
<thead>
<tr><th>table_name</th><th>column_name</th><th>data_type</th></tr>
</thead>
<tbody>
<tr><td>ExampleList</td><td>id</td><td>integer</td></tr>
<tr><td>ExampleList</td><td>age</td><td>integer</td></tr>
</tbody>
</table>
<p>If we update our Keystone List either by renaming fields or adding new fields, we might encounter errors next time we start Keystone. This is because the database schema has changed and Keystone doesn't know what to do with existing data or won't be able to save new data. Let's imagine that because we are responsible with data collection we want to update the list to only include an age range rather than a specific age. We might update the field to use a select type:</p>
<pre><code class="language-javascript">keystone.createList('ExampleList', {
  fields: {
    age: { type: Select, options: '0-18, 19-35, 36-50, 50+' },
  },
});
</code></pre>
<p>If we restart Keystone after this change it will throw an error. The <code>data_type</code> of the <code>age</code> column is now a <code>text</code> value and it should contain a string representation of the age range. The table should change to something like the following:</p>
<table>
<thead>
<tr><th>table_name</th><th>column_name</th><th>data_type</th></tr>
</thead>
<tbody>
<tr><td>ExampleList</td><td>id</td><td>integer</td></tr>
<tr><td>ExampleList</td><td>age</td><td>text</td></tr>
</tbody>
</table>
<p>Keystone cannot make this change for you because there could be existing data with a type of <code>integer</code>. Sometimes migrations can be as simple as converting an <code>integer</code> to a <code>string</code> but in this case we need to programatically resolving the appropriate value.</p>
<h2>Migration options</h2>
<h3>Drop and replace</h3>
<p>In development sometimes it can be helpful to drop the database everytime Keystone is restarted. To do this using the <code>KnexAdapter</code> you can pass the <code>dropDatabase</code> option to the adapter:</p>
<pre><code class="language-js">const { KnexAdapter } = require('@keystonejs/adapter-knex');
const adapter = new KnexAdapter({ dropDatabase: true });
</code></pre>
<p>This might be enough for small projects but it won't be ideal for everyone. If you want data to persist in development you need to re-initialise the database or preform migrations. And regardless of the development environment, almost all projects will eventually need to make changes to a List table in production. For this there are a number of solutions.</p>
<h3>Manual migrations</h3>
<p>The most basic solution is to make these changes on the database. You can do this via a command-line, or you might prefer a graphical DB admin interface. For Mongo you might try <a href="https://studio3t.com/download/">Studio 3T</a> which is free for non-commercial use. For Postgres you can try <a href="https://www.pgadmin.org/">pgadmin</a>. There are a lot of other options and you should find one that works for you.</p>
<p>Here's how you might do a data migration for the <code>ExampleList</code> above in Postgres:</p>
<pre><code class="language-sql">ALTER TABLE &quot;ExampleList&quot;
ALTER COLUMN &quot;age&quot; TYPE text
    USING (
    CASE WHEN age&lt;=18 THEN '0-18'
        WHEN age&lt;=35 THEN '19-35'
        WHEN age&lt;=50 THEN '36-50'
        ELSE '50+'
    END);
</code></pre>
<h3>Managed migrations</h3>
<p>Keystone database adapters use Mongoose and Knex under the hood, both of which have migrations solutions. Rather than running SQL queries directly, you can write migrations using JavaScript, and tools like the <a href="http://knexjs.org/#Migrations">Knex CLI</a> allow you to keep track of which migrations have been applied. You seed the database, run or rollback specific migrations or apply all missing migrations in the correct order.</p>
<p>Managed migrations are useful when working in a team or with duplicated deployments (e.g., development and production). They help keep database changes consistent, even when multiple developers are working with multiple databases.</p>
<p>For small scale projects you can avoid the need for many migrations with careful planning, drop the database frequently while in development and use GUI tools to apply manual updates.</p>
</div></section></div><footer class="footer-clean"><div class="container"><div class="row justify-content-center"><div class="col-sm-4 col-md-3 item"><h3 class="text-primary">Dịch vụ</h3><ul class="list-unstyled"><li><a class="text-body" href="#">Thiết kế website</a></li><li><a class="text-body" href="#">Phát triển phần mềm</a></li><li><a class="text-body" href="#">Hosting</a></li></ul></div><div class="col-sm-4 col-md-3 item"><h3 class="text-primary">Phát triển bởi</h3><ul class="list-inline d-inline"><li class="list-inline-item d-inline-block">Sinh viên trường ĐH Bách Khoa Đà Nẵng.</li></ul><h3 class="text-primary">Công ty</h3><ul class="list-unstyled"><li>Công ty TNHH Công Nghệ Điện Tử Quảng Đà.</li><li>Mã số thuế: 4001202704.</li><li>Địa chỉ: Thôn 2, Xã Bình Đào, Huyện Thăng Bình, Tỉnh Quảng Nam.<br/></li><li></li></ul></div><div class="col-sm-4 col-md-3 item"><h3 class="text-primary">Liên hệ</h3><ul class="list-unstyled"><li>Leader: Trần Ngọc Huy</li><li>Điện thoại/Zalo: 0332813077</li><li>Địa chỉ: 54 Nguyễn Lương Bằng, Liên Chiểu, Đà Nẵng.</li><li></li></ul><img class="w-100" src="/assets/img/zalo.jpg?h=614debe3b6ec66917ebd818aa1c50b6e" loading="lazy" alt="Zalo"/></div></div></div><img src="/assets/img/wave(2).svg?h=5ad7ab1ad1557422fec002e92b1ae54b" alt="Nền"/></footer><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"markdownPost":{"name":null,"url":null,"content":"\u003c!--[meta]\nsection: guides\ntitle: Migrations\nsubSection: advanced\n[meta]--\u003e\n\n# Migrations in Keystone\n\nAs your app grows new features, you'll inevitably need to change some of your existing List definitions. When you do, you'll also need to migrate the data and schema in your database backend.\n\n**Keystone can't automatically manage these migrations for you** because it doesn't know what to do with the existing data. This guide will explain when and why you need database migrations and offer some basic solutions to get you started.\n\nWhen you create a new List, depending on the adapter, Keystone will initialise a database table with columns for each of the fields defined in the List. Let's look at an example.\n\n```javascript\nconst { KnexAdapter } = require('@keystonejs/adapter-knex');\n\nconst keystone = new Keystone({\n  adapter: new KnexAdapter(),\n});\n\nkeystone.createList('ExampleList', {\n  fields: {\n    age: { type: Integer },\n  },\n});\n```\n\nUsing the KnexAdapter if we create an `ExampleList` that contains an `Integer` field called `age` when we start Keystone for the first time it will generate a table with an `id` and `age` column:\n\n| table_name  | column_name | data_type |\n| ----------- | ----------- | --------- |\n| ExampleList | id          | integer   |\n| ExampleList | age         | integer   |\n\nIf we update our Keystone List either by renaming fields or adding new fields, we might encounter errors next time we start Keystone. This is because the database schema has changed and Keystone doesn't know what to do with existing data or won't be able to save new data. Let's imagine that because we are responsible with data collection we want to update the list to only include an age range rather than a specific age. We might update the field to use a select type:\n\n```javascript\nkeystone.createList('ExampleList', {\n  fields: {\n    age: { type: Select, options: '0-18, 19-35, 36-50, 50+' },\n  },\n});\n```\n\nIf we restart Keystone after this change it will throw an error. The `data_type` of the `age` column is now a `text` value and it should contain a string representation of the age range. The table should change to something like the following:\n\n| table_name  | column_name | data_type |\n| ----------- | ----------- | --------- |\n| ExampleList | id          | integer   |\n| ExampleList | age         | text      |\n\nKeystone cannot make this change for you because there could be existing data with a type of `integer`. Sometimes migrations can be as simple as converting an `integer` to a `string` but in this case we need to programatically resolving the appropriate value.\n\n## Migration options\n\n### Drop and replace\n\nIn development sometimes it can be helpful to drop the database everytime Keystone is restarted. To do this using the `KnexAdapter` you can pass the `dropDatabase` option to the adapter:\n\n```js\nconst { KnexAdapter } = require('@keystonejs/adapter-knex');\nconst adapter = new KnexAdapter({ dropDatabase: true });\n```\n\nThis might be enough for small projects but it won't be ideal for everyone. If you want data to persist in development you need to re-initialise the database or preform migrations. And regardless of the development environment, almost all projects will eventually need to make changes to a List table in production. For this there are a number of solutions.\n\n### Manual migrations\n\nThe most basic solution is to make these changes on the database. You can do this via a command-line, or you might prefer a graphical DB admin interface. For Mongo you might try [Studio 3T](https://studio3t.com/download/) which is free for non-commercial use. For Postgres you can try [pgadmin](https://www.pgadmin.org/). There are a lot of other options and you should find one that works for you.\n\nHere's how you might do a data migration for the `ExampleList` above in Postgres:\n\n```sql\nALTER TABLE \"ExampleList\"\nALTER COLUMN \"age\" TYPE text\n    USING (\n    CASE WHEN age\u003c=18 THEN '0-18'\n        WHEN age\u003c=35 THEN '19-35'\n        WHEN age\u003c=50 THEN '36-50'\n        ELSE '50+'\n    END);\n```\n\n### Managed migrations\n\nKeystone database adapters use Mongoose and Knex under the hood, both of which have migrations solutions. Rather than running SQL queries directly, you can write migrations using JavaScript, and tools like the [Knex CLI](http://knexjs.org/#Migrations) allow you to keep track of which migrations have been applied. You seed the database, run or rollback specific migrations or apply all missing migrations in the correct order.\n\nManaged migrations are useful when working in a team or with duplicated deployments (e.g., development and production). They help keep database changes consistent, even when multiple developers are working with multiple databases.\n\nFor small scale projects you can avoid the need for many migrations with careful planning, drop the database frequently while in development and use GUI tools to apply manual updates.\n"}},"__N_SSG":true},"page":"/post/[path]","query":{"path":"_docs_keystone_guides_migrations.md"},"buildId":"IU2MQGFEli_aRg5UtGR53","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-4beebf4ac9054f0bf4e6.js"></script><script src="/_next/static/chunks/main-71dd292baef5e0c3d163.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9116e7bff2bfccdffa19.js" async=""></script><script src="/_next/static/chunks/8638dade453fc283329f8b8dee6f6817b55b3944.9475e511f211dbecfbed.js" async=""></script><script src="/_next/static/chunks/pages/_app-de7ed68c6e8649dd556c.js" async=""></script><script src="/_next/static/chunks/pages/post/%5Bpath%5D-98a2b37c69fbc1053078.js" async=""></script><script src="/_next/static/IU2MQGFEli_aRg5UtGR53/_buildManifest.js" async=""></script><script src="/_next/static/IU2MQGFEli_aRg5UtGR53/_ssgManifest.js" async=""></script></body></html>