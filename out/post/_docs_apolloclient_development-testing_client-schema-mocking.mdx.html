<!DOCTYPE html><html lang="vi"><head><meta charset="utf-8"/><meta property="og:type" content="website"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicon-16x16.png?h=cf681ecd5bbf6d03e3056673d0122646"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicon-32x32.png?h=dada6ed6c75053e6f84520a87241cd23"/><link rel="icon" type="image/png" sizes="180x180" href="/assets/img/apple-icon-180x180.png?h=b5b7d59e89a4d05d1aca1c00dfe1b70f"/><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/android-icon-192x192.png?h=033de9a23d4cfa21fd3383f727564736"/><link rel="icon" type="image/png" sizes="310x310" href="/assets/img/ms-icon-310x310.png?h=f9285fe98206007e11710305c82d9ea2"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/4.5.3/united/bootstrap.min.css"/><link rel="stylesheet" href="/assets/css/styles.min.css?h=69c29b29303563e0ebbd0e0e69162409"/><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2f26bb9842d84a608fa3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2f26bb9842d84a608fa3.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-71dd292baef5e0c3d163.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9116e7bff2bfccdffa19.js" as="script"/><link rel="preload" href="/_next/static/chunks/8638dade453fc283329f8b8dee6f6817b55b3944.9475e511f211dbecfbed.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-de7ed68c6e8649dd556c.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/post/%5Bpath%5D-98a2b37c69fbc1053078.js" as="script"/></head><body><header><img data-aos="fade-down" class="img-wave" src="/assets/img/wave(1).svg" alt="Nền"/><nav class="navbar navbar-light navbar-expand-md navigation-clean py-2"><div class="container"><img class="mr-3" src="/assets/img/favicon-32x32.png?h=dada6ed6c75053e6f84520a87241cd23" alt="logo" width="32" height="32"/><a class="navbar-brand p-0" href="/"><h6 class="text-uppercase m-0 p-0">loa loa team</h6> </a><button data-toggle="collapse" class="navbar-toggler" data-target="#navcol-1"><span class="sr-only">Toggle navigation</span><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navcol-1"><ul class="nav navbar-nav ml-auto"><li class="nav-item"><a class="nav-link" href="/">Trang chủ</a></li><li class="nav-item"><a class="nav-link" href="/projects">Dự án</a></li><li class="nav-item"><a class="nav-link" href="/docs">Tài liệu</a></li><li class="nav-item"><a class="nav-link" href="/blogs">Bài viết</a></li></ul></div></div></nav></header><div id="__next"><section class="container"><div><hr>
<p>title: Mocking new schema capabilities
description: How to build UI features before your GraphQL API supports them</p>
<hr>
<p>Imagine we're building out a new feature in our Space Explorer app — we'd like to display a description of each rocket we can choose — but the backend support for this feature isn't going to be available for another few weeks. In keeping with <a href="https://www.apollographql.com/docs/tutorial/schema.html#write-schema">schema-first design</a>, the team has decided that we'll be adding a new field called <code>description</code> to an existing type in our schema called <code>Rocket</code>.</p>
<p>Even though this field doesn't exist in the schema yet, we can take advantage of client schemas to document it as a <em>client-side</em> field. In this guide, we'll walk through a simple recipe for this technique:</p>
<ul>
<li>declare client-side extensions to the schema using Apollo Client;</li>
<li>enhance client resolvers with mock data;</li>
<li>write GraphQL queries that leverage client-only types and fields.</li>
</ul>
<h2>1. Extend your server schema with a client-only field.</h2>
<p>Before we can include this data in the UI, we'll need to define a client schema that extends our server schema. We'll start by constructing an instance of ApolloClient with a few small additions. Simply pass in <code>typeDefs</code> with extensions to the schema and <code>resolvers</code> which actually provide the mock data:</p>
<pre><code class="language-js">const typeDefs = gql`
  extend type Rocket {
    description: String!
  }
`;

const resolvers = {
  Rocket: {
    description: () =&gt; &quot;A boilerplate standard space rocket&quot;
  }
};

const client = new ApolloClient({
  cache,
  link,
  typeDefs,
  resolvers
});
</code></pre>
<p>Documenting your client-side API in <a href="https://apollographql.com/docs/graphql-tools/generate-schema.html#schema-language">Schema Definition Language</a> is incredibly valuable, as other developers can easily see what client state is available in your app. Developers familiar with GraphQL schemas should quickly be able to understand how to query for these fields in other places throughout your app.</p>
<p>Additional tools available from Apollo can further enrich the developer experience when working with client-side schemas. The Apollo Visual Studio Code Plugin provides autocompletion of client-side fields as well as inline mouse-over documentation:</p>
<p><img src="../assets/client-mocking/vscode-autocomplete.png" alt="VSCode Autocompletion">
<img src="../assets/client-mocking/vscode-typeinfo.png" alt="VSCode Type Info"></p>
<p>We'll also see error messages in the VSCode console if we add fields that collide with the server-side schema:</p>
<p><img src="../assets/client-mocking/vscode-errors.png" alt="VSCode Console Errors"></p>
<h2>2. Introduce richer mock data.</h2>
<p>Now that we have a basic resolver, we might find that during testing it's a bit boring to show the same boilerplate text every time. In fact we might want to test different lengths of text to make sure our layout still looks good. Introducing a mock data helper library such as <a href="https://github.com/marak/Faker.js/">faker.js</a> can help keep the mock data varied while testing. We can incorporate it easily into this workflow:</p>
<pre><code class="language-js">import faker from &quot;faker/locale/en&quot;;

// returns either 1 or 2 latin sentences, like
// 'Lorem ipsum dolor sit amet, consectetur adipiscing elit...
const oneOrTwoSentences = () =&gt;
  faker.lorem.sentences(Math.random() &lt; 0.5 ? 1 : 2);

const resolvers = {
  Rocket: {
    description: () =&gt; oneOrTwoSentences()
  }
};
</code></pre>
<blockquote>
<p><em>Note:</em> the faker.js library comes bundled with lots and lots of strings that can consume precious bundle bytes. For this reason you should make sure to only include the faker.js dependency in development mode and take care not to include this in your production bundle.</p>
</blockquote>
<h2>3. Query the mocked field with the <code>@client</code> directive.</h2>
<p>Now, you’re ready to query your new field inside the <code>RocketDetails</code> component. Just add your new field to the query and specify the <code>@client</code> directive, and start using it in your UI.</p>
<pre><code class="language-jsx">const GET_ROCKET_DETAILS = gql`
  query RocketDetails($rocketId: ID!) {
    rocket(id: $rocketId) {
      type
      description @client
    }
  }
`;

export default function RocketDetails({ rocketId }) {
  const { data } = useQuery(GET_ROCKET_DETAILS, { variables: { rocketId } });
  return (
    &lt;div&gt;
      &lt;p&gt;Rocket Type: {data.rocket.type}&lt;/p&gt;
      &lt;p&gt;Description: {data.rocket.description}&lt;/p&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h2>4. Toggle on “real” data.</h2>
<p>Once the feature is ready on the backend, just remove the <code>@client</code> directive from your query. You should now be able to see your real production data returned instead. It's probably a good idea to clean up any unused client schema and resolvers at this time.</p>
<p>There you have it, a workflow for developing new features with new schema fields ahead of the actual schema implementation. For further reading, visit the <a href="https://www.apollographql.com/docs/tutorial/local-state.html#virtual-fields">tutorial guide</a> which describes how to use client fields to manage local state in greater depth.</p>
<p>If you have feedback on this workflow, experiences you want to share, or just want to join the general discussion on client-side development and mocking, join us on <a href="https://spectrum.chat/apollo">Spectrum</a>!</p>
</div></section></div><footer class="footer-clean"><div class="container"><div class="row justify-content-center"><div class="col-sm-4 col-md-3 item"><h3 class="text-primary">Dịch vụ</h3><ul class="list-unstyled"><li><a class="text-body" href="#">Thiết kế website</a></li><li><a class="text-body" href="#">Phát triển phần mềm</a></li><li><a class="text-body" href="#">Hosting</a></li></ul></div><div class="col-sm-4 col-md-3 item"><h3 class="text-primary">Phát triển bởi</h3><ul class="list-inline d-inline"><li class="list-inline-item d-inline-block">Sinh viên trường ĐH Bách Khoa Đà Nẵng.</li></ul><h3 class="text-primary">Công ty</h3><ul class="list-unstyled"><li>Công ty TNHH Công Nghệ Điện Tử Quảng Đà.</li><li>Mã số thuế: 4001202704.</li><li>Địa chỉ: Thôn 2, Xã Bình Đào, Huyện Thăng Bình, Tỉnh Quảng Nam.<br/></li><li></li></ul></div><div class="col-sm-4 col-md-3 item"><h3 class="text-primary">Liên hệ</h3><ul class="list-unstyled"><li>Leader: Trần Ngọc Huy</li><li>Điện thoại/Zalo: 0332813077</li><li>Địa chỉ: 54 Nguyễn Lương Bằng, Liên Chiểu, Đà Nẵng.</li><li></li></ul><img class="w-100" src="/assets/img/zalo.jpg?h=614debe3b6ec66917ebd818aa1c50b6e" loading="lazy" alt="Zalo"/></div></div></div><img src="/assets/img/wave(2).svg?h=5ad7ab1ad1557422fec002e92b1ae54b" alt="Nền"/></footer><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"markdownPost":{"name":null,"url":null,"content":"---\ntitle: Mocking new schema capabilities\ndescription: How to build UI features before your GraphQL API supports them\n---\n\nImagine we're building out a new feature in our Space Explorer app — we'd like to display a description of each rocket we can choose — but the backend support for this feature isn't going to be available for another few weeks. In keeping with [schema-first design](https://www.apollographql.com/docs/tutorial/schema.html#write-schema), the team has decided that we'll be adding a new field called `description` to an existing type in our schema called `Rocket`.\n\nEven though this field doesn't exist in the schema yet, we can take advantage of client schemas to document it as a _client-side_ field. In this guide, we'll walk through a simple recipe for this technique:\n\n- declare client-side extensions to the schema using Apollo Client;\n- enhance client resolvers with mock data;\n- write GraphQL queries that leverage client-only types and fields.\n\n## 1. Extend your server schema with a client-only field.\n\nBefore we can include this data in the UI, we'll need to define a client schema that extends our server schema. We'll start by constructing an instance of ApolloClient with a few small additions. Simply pass in `typeDefs` with extensions to the schema and `resolvers` which actually provide the mock data:\n\n```js\nconst typeDefs = gql`\n  extend type Rocket {\n    description: String!\n  }\n`;\n\nconst resolvers = {\n  Rocket: {\n    description: () =\u003e \"A boilerplate standard space rocket\"\n  }\n};\n\nconst client = new ApolloClient({\n  cache,\n  link,\n  typeDefs,\n  resolvers\n});\n```\n\nDocumenting your client-side API in [Schema Definition Language](https://apollographql.com/docs/graphql-tools/generate-schema.html#schema-language) is incredibly valuable, as other developers can easily see what client state is available in your app. Developers familiar with GraphQL schemas should quickly be able to understand how to query for these fields in other places throughout your app.\n\nAdditional tools available from Apollo can further enrich the developer experience when working with client-side schemas. The Apollo Visual Studio Code Plugin provides autocompletion of client-side fields as well as inline mouse-over documentation:\n\n![VSCode Autocompletion](../assets/client-mocking/vscode-autocomplete.png)\n![VSCode Type Info](../assets/client-mocking/vscode-typeinfo.png)\n\nWe'll also see error messages in the VSCode console if we add fields that collide with the server-side schema:\n\n![VSCode Console Errors](../assets/client-mocking/vscode-errors.png)\n\n## 2. Introduce richer mock data.\n\nNow that we have a basic resolver, we might find that during testing it's a bit boring to show the same boilerplate text every time. In fact we might want to test different lengths of text to make sure our layout still looks good. Introducing a mock data helper library such as [faker.js](https://github.com/marak/Faker.js/) can help keep the mock data varied while testing. We can incorporate it easily into this workflow:\n\n```js\nimport faker from \"faker/locale/en\";\n\n// returns either 1 or 2 latin sentences, like\n// 'Lorem ipsum dolor sit amet, consectetur adipiscing elit...\nconst oneOrTwoSentences = () =\u003e\n  faker.lorem.sentences(Math.random() \u003c 0.5 ? 1 : 2);\n\nconst resolvers = {\n  Rocket: {\n    description: () =\u003e oneOrTwoSentences()\n  }\n};\n```\n\n\u003e _Note:_ the faker.js library comes bundled with lots and lots of strings that can consume precious bundle bytes. For this reason you should make sure to only include the faker.js dependency in development mode and take care not to include this in your production bundle.\n\n## 3. Query the mocked field with the `@client` directive.\n\nNow, you’re ready to query your new field inside the `RocketDetails` component. Just add your new field to the query and specify the `@client` directive, and start using it in your UI.\n\n```jsx\nconst GET_ROCKET_DETAILS = gql`\n  query RocketDetails($rocketId: ID!) {\n    rocket(id: $rocketId) {\n      type\n      description @client\n    }\n  }\n`;\n\nexport default function RocketDetails({ rocketId }) {\n  const { data } = useQuery(GET_ROCKET_DETAILS, { variables: { rocketId } });\n  return (\n    \u003cdiv\u003e\n      \u003cp\u003eRocket Type: {data.rocket.type}\u003c/p\u003e\n      \u003cp\u003eDescription: {data.rocket.description}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n## 4. Toggle on “real” data.\n\nOnce the feature is ready on the backend, just remove the `@client` directive from your query. You should now be able to see your real production data returned instead. It's probably a good idea to clean up any unused client schema and resolvers at this time.\n\nThere you have it, a workflow for developing new features with new schema fields ahead of the actual schema implementation. For further reading, visit the [tutorial guide](https://www.apollographql.com/docs/tutorial/local-state.html#virtual-fields) which describes how to use client fields to manage local state in greater depth.\n\nIf you have feedback on this workflow, experiences you want to share, or just want to join the general discussion on client-side development and mocking, join us on [Spectrum](https://spectrum.chat/apollo)!\n"}},"__N_SSG":true},"page":"/post/[path]","query":{"path":"_docs_apolloclient_development-testing_client-schema-mocking.mdx"},"buildId":"IU2MQGFEli_aRg5UtGR53","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-4beebf4ac9054f0bf4e6.js"></script><script src="/_next/static/chunks/main-71dd292baef5e0c3d163.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9116e7bff2bfccdffa19.js" async=""></script><script src="/_next/static/chunks/8638dade453fc283329f8b8dee6f6817b55b3944.9475e511f211dbecfbed.js" async=""></script><script src="/_next/static/chunks/pages/_app-de7ed68c6e8649dd556c.js" async=""></script><script src="/_next/static/chunks/pages/post/%5Bpath%5D-98a2b37c69fbc1053078.js" async=""></script><script src="/_next/static/IU2MQGFEli_aRg5UtGR53/_buildManifest.js" async=""></script><script src="/_next/static/IU2MQGFEli_aRg5UtGR53/_ssgManifest.js" async=""></script></body></html>