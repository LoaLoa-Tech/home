<!DOCTYPE html><html lang="vi"><head><meta charset="utf-8"/><meta property="og:type" content="website"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicon-16x16.png?h=cf681ecd5bbf6d03e3056673d0122646"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicon-32x32.png?h=dada6ed6c75053e6f84520a87241cd23"/><link rel="icon" type="image/png" sizes="180x180" href="/assets/img/apple-icon-180x180.png?h=b5b7d59e89a4d05d1aca1c00dfe1b70f"/><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/android-icon-192x192.png?h=033de9a23d4cfa21fd3383f727564736"/><link rel="icon" type="image/png" sizes="310x310" href="/assets/img/ms-icon-310x310.png?h=f9285fe98206007e11710305c82d9ea2"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/4.5.3/united/bootstrap.min.css"/><link rel="stylesheet" href="/assets/css/styles.min.css?h=69c29b29303563e0ebbd0e0e69162409"/><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2f26bb9842d84a608fa3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2f26bb9842d84a608fa3.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-71dd292baef5e0c3d163.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9116e7bff2bfccdffa19.js" as="script"/><link rel="preload" href="/_next/static/chunks/8638dade453fc283329f8b8dee6f6817b55b3944.9475e511f211dbecfbed.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-de7ed68c6e8649dd556c.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/post/%5Bpath%5D-98a2b37c69fbc1053078.js" as="script"/></head><body><header><img data-aos="fade-down" class="img-wave" src="/assets/img/wave(1).svg" alt="Nền"/><nav class="navbar navbar-light navbar-expand-md navigation-clean py-2"><div class="container"><img class="mr-3" src="/assets/img/favicon-32x32.png?h=dada6ed6c75053e6f84520a87241cd23" alt="logo" width="32" height="32"/><a class="navbar-brand p-0" href="/"><h6 class="text-uppercase m-0 p-0">loa loa team</h6> </a><button data-toggle="collapse" class="navbar-toggler" data-target="#navcol-1"><span class="sr-only">Toggle navigation</span><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navcol-1"><ul class="nav navbar-nav ml-auto"><li class="nav-item"><a class="nav-link" href="/">Trang chủ</a></li><li class="nav-item"><a class="nav-link" href="/projects">Dự án</a></li><li class="nav-item"><a class="nav-link" href="/docs">Tài liệu</a></li><li class="nav-item"><a class="nav-link" href="/blogs">Bài viết</a></li></ul></div></div></nav></header><div id="__next"><section class="container"><div><hr>
<p>id: concurrent-mode-reference
title: Concurrent Mode API Reference (Experimental)
permalink: docs/concurrent-mode-reference.html
prev: concurrent-mode-adoption.html</p>
<hr>
<style>
.scary > blockquote {
  background-color: rgba(237, 51, 21, 0.2);
  border-left-color: #ed3315;
}
</style>
<div class="scary">
<blockquote>
<p>Caution:</p>
<p>This page describes <strong>experimental features that are <a href="/docs/concurrent-mode-adoption.html">not yet available</a> in a stable release</strong>. Don't rely on experimental builds of React in production apps. These features may change significantly and without a warning before they become a part of React.</p>
<p>This documentation is aimed at early adopters and people who are curious. <strong>If you're new to React, don't worry about these features</strong> -- you don't need to learn them right now.</p>
</blockquote>
</div>
<p>This page is an API reference for the React <a href="/docs/concurrent-mode-intro.html">Concurrent Mode</a>. If you're looking for a guided introduction instead, check out <a href="/docs/concurrent-mode-patterns.html">Concurrent UI Patterns</a>.</p>
<p><strong>Note: This is a Community Preview and not the final stable version. There will likely be future changes to these APIs. Use at your own risk!</strong></p>
<ul>
<li><a href="#concurrent-mode">Enabling Concurrent Mode</a>
<ul>
<li><a href="#createroot"><code>createRoot</code></a></li>
<li><a href="#createblockingroot"><code>createBlockingRoot</code></a></li>
</ul></li>
<li><a href="#suspense">Suspense</a>
<ul>
<li><a href="#suspensecomponent"><code>Suspense</code></a></li>
<li><a href="#suspenselist"><code>SuspenseList</code></a></li>
<li><a href="#usetransition"><code>useTransition</code></a></li>
<li><a href="#usedeferredvalue"><code>useDeferredValue</code></a></li>
</ul></li>
</ul>
<h2>Enabling Concurrent Mode {#concurrent-mode}</h2>
<h3><code>createRoot</code> {#createroot}</h3>
<pre><code class="language-js">ReactDOM.createRoot(rootNode).render(&lt;App /&gt;);
</code></pre>
<p>Replaces <code>ReactDOM.render(&lt;App /&gt;, rootNode)</code> and enables Concurrent Mode.</p>
<p>For more information on Concurrent Mode, check out the <a href="/docs/concurrent-mode-intro.html">Concurrent Mode documentation.</a></p>
<h3><code>createBlockingRoot</code> {#createblockingroot}</h3>
<pre><code class="language-js">ReactDOM.createBlockingRoot(rootNode).render(&lt;App /&gt;)
</code></pre>
<p>Replaces <code>ReactDOM.render(&lt;App /&gt;, rootNode)</code> and enables <a href="/docs/concurrent-mode-adoption.html#migration-step-blocking-mode">Blocking Mode</a>.</p>
<p>Opting into Concurrent Mode introduces semantic changes to how React works. This means that you can't use Concurrent Mode in just a few components. Because of this, some apps may not be able to migrate directly to Concurrent Mode.</p>
<p>Blocking Mode only contains a small subset of Concurrent Mode features and is intended as an intermediary migration step for apps that are unable to migrate directly.</p>
<h2>Suspense API {#suspense}</h2>
<h3><code>Suspense</code> {#suspensecomponent}</h3>
<pre><code class="language-js">&lt;Suspense fallback={&lt;h1&gt;Loading...&lt;/h1&gt;}&gt;
  &lt;ProfilePhoto /&gt;
  &lt;ProfileDetails /&gt;
&lt;/Suspense&gt;
</code></pre>
<p><code>Suspense</code> lets your components &quot;wait&quot; for something before they can render, showing a fallback while waiting.</p>
<p>In this example, <code>ProfileDetails</code> is waiting for an asynchronous API call to fetch some data. While we wait for <code>ProfileDetails</code> and <code>ProfilePhoto</code>, we will show the <code>Loading...</code> fallback instead. It is important to note that until all children inside <code>&lt;Suspense&gt;</code> has loaded, we will continue to show the fallback.</p>
<p><code>Suspense</code> takes two props:</p>
<ul>
<li><strong>fallback</strong> takes a loading indicator. The fallback is shown until all of the children of the <code>Suspense</code> component have finished rendering.</li>
<li><strong>unstable_avoidThisFallback</strong> takes a boolean. It tells React whether to &quot;skip&quot; revealing this boundary during the initial load. This API will likely be removed in a future release.</li>
</ul>
<h3><code>&lt;SuspenseList&gt;</code> {#suspenselist}</h3>
<pre><code class="language-js">&lt;SuspenseList revealOrder=&quot;forwards&quot;&gt;
  &lt;Suspense fallback={'Loading...'}&gt;
    &lt;ProfilePicture id={1} /&gt;
  &lt;/Suspense&gt;
  &lt;Suspense fallback={'Loading...'}&gt;
    &lt;ProfilePicture id={2} /&gt;
  &lt;/Suspense&gt;
  &lt;Suspense fallback={'Loading...'}&gt;
    &lt;ProfilePicture id={3} /&gt;
  &lt;/Suspense&gt;
  ...
&lt;/SuspenseList&gt;
</code></pre>
<p><code>SuspenseList</code> helps coordinate many components that can suspend by orchestrating the order in which these components are revealed to the user.</p>
<p>When multiple components need to fetch data, this data may arrive in an unpredictable order. However, if you wrap these items in a <code>SuspenseList</code>, React will not show an item in the list until previous items have been displayed (this behavior is adjustable).</p>
<p><code>SuspenseList</code> takes two props:</p>
<ul>
<li><strong>revealOrder (forwards, backwards, together)</strong> defines the order in which the <code>SuspenseList</code> children should be revealed.
<ul>
<li><code>together</code> reveals <em>all</em> of them when they're ready instead of one by one.</li>
</ul></li>
<li><strong>tail (collapsed, hidden)</strong> dictates how unloaded items in a <code>SuspenseList</code> is shown.
<ul>
<li>By default, <code>SuspenseList</code> will show all fallbacks in the list.</li>
<li><code>collapsed</code> shows only the next fallback in the list.</li>
<li><code>hidden</code> doesn't show any unloaded items.</li>
</ul></li>
</ul>
<p>Note that <code>SuspenseList</code> only operates on the closest <code>Suspense</code> and <code>SuspenseList</code> components below it. It does not search for boundaries deeper than one level. However, it is possible to nest multiple <code>SuspenseList</code> components in each other to build grids.</p>
<h3><code>useTransition</code> {#usetransition}</h3>
<pre><code class="language-js">const SUSPENSE_CONFIG = { timeoutMs: 2000 };

const [startTransition, isPending] = useTransition(SUSPENSE_CONFIG);
</code></pre>
<p><code>useTransition</code> allows components to avoid undesirable loading states by waiting for content to load before <strong>transitioning to the next screen</strong>. It also allows components to defer slower, data fetching updates until subsequent renders so that more crucial updates can be rendered immediately.</p>
<p>The <code>useTransition</code> hook returns two values in an array.</p>
<ul>
<li><code>startTransition</code> is a function that takes a callback. We can use it to tell React which state we want to defer.</li>
<li><code>isPending</code> is a boolean. It's React's way of informing us whether we're waiting for the transition to finish.</li>
</ul>
<p><strong>If some state update causes a component to suspend, that state update should be wrapped in a transition.</strong></p>
<pre><code class="language-js">const SUSPENSE_CONFIG = { timeoutMs: 2000 };

function App() {
  const [resource, setResource] = useState(initialResource);
  const [startTransition, isPending] = useTransition(SUSPENSE_CONFIG);
  return (
    &lt;&gt;
      &lt;button
        disabled={isPending}
        onClick={() =&gt; {
          startTransition(() =&gt; {
            const nextUserId = getNextId(resource.userId);
            setResource(fetchProfileData(nextUserId));
          });
        }}
      &gt;
        Next
      &lt;/button&gt;
      {isPending ? &quot; Loading...&quot; : null}
      &lt;Suspense fallback={&lt;Spinner /&gt;}&gt;
        &lt;ProfilePage resource={resource} /&gt;
      &lt;/Suspense&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>In this code, we've wrapped our data fetching with <code>startTransition</code>. This allows us to start fetching the profile data right away, while deferring the render of the next profile page and its associated <code>Spinner</code> for 2 seconds (the time shown in <code>timeoutMs</code>).</p>
<p>The <code>isPending</code> boolean lets React know that our component is transitioning, so we are able to let the user know this by showing some loading text on the previous profile page.</p>
<p><strong>For an in-depth look at transitions, you can read <a href="/docs/concurrent-mode-patterns.html#transitions">Concurrent UI Patterns</a>.</strong></p>
<h4>useTransition Config {#usetransition-config}</h4>
<pre><code class="language-js">const SUSPENSE_CONFIG = { timeoutMs: 2000 };
</code></pre>
<p><code>useTransition</code> accepts an <strong>optional Suspense Config</strong> with a <code>timeoutMs</code>. This timeout (in milliseconds) tells React how long to wait before showing the next state (the new Profile Page in the above example).</p>
<p><strong>Note: We recommend that you share Suspense Config between different modules.</strong></p>
<h3><code>useDeferredValue</code> {#usedeferredvalue}</h3>
<pre><code class="language-js">const deferredValue = useDeferredValue(value, { timeoutMs: 2000 });
</code></pre>
<p>Returns a deferred version of the value that may &quot;lag behind&quot; it for at most <code>timeoutMs</code>.</p>
<p>This is commonly used to keep the interface responsive when you have something that renders immediately based on user input and something that needs to wait for a data fetch.</p>
<p>A good example of this is a text input.</p>
<pre><code class="language-js">function App() {
  const [text, setText] = useState(&quot;hello&quot;);
  const deferredText = useDeferredValue(text, { timeoutMs: 2000 }); 

  return (
    &lt;div className=&quot;App&quot;&gt;
      {/* Keep passing the current text to the input */}
      &lt;input value={text} onChange={handleChange} /&gt;
      ...
      {/* But the list is allowed to &quot;lag behind&quot; when necessary */}
      &lt;MySlowList text={deferredText} /&gt;
    &lt;/div&gt;
  );
 }
</code></pre>
<p>This allows us to start showing the new text for the <code>input</code> immediately, which allows the webpage to feel responsive. Meanwhile, <code>MySlowList</code> &quot;lags behind&quot; for up to 2 seconds according to the <code>timeoutMs</code> before updating, allowing it to render with the current text in the background.</p>
<p><strong>For an in-depth look at deferring values, you can read <a href="/docs/concurrent-mode-patterns.html#deferring-a-value">Concurrent UI Patterns</a>.</strong></p>
<h4>useDeferredValue Config {#usedeferredvalue-config}</h4>
<pre><code class="language-js">const SUSPENSE_CONFIG = { timeoutMs: 2000 };
</code></pre>
<p><code>useDeferredValue</code> accepts an <strong>optional Suspense Config</strong> with a <code>timeoutMs</code>. This timeout (in milliseconds) tells React how long the deferred value is allowed to lag behind.</p>
<p>React will always try to use a shorter lag when network and device allows it.</p>
</div></section></div><footer class="footer-clean"><div class="container"><div class="row justify-content-center"><div class="col-sm-4 col-md-3 item"><h3 class="text-primary">Dịch vụ</h3><ul class="list-unstyled"><li><a class="text-body" href="#">Thiết kế website</a></li><li><a class="text-body" href="#">Phát triển phần mềm</a></li><li><a class="text-body" href="#">Hosting</a></li></ul></div><div class="col-sm-4 col-md-3 item"><h3 class="text-primary">Phát triển bởi</h3><ul class="list-inline d-inline"><li class="list-inline-item d-inline-block">Sinh viên trường ĐH Bách Khoa Đà Nẵng.</li></ul><h3 class="text-primary">Công ty</h3><ul class="list-unstyled"><li>Công ty TNHH Công Nghệ Điện Tử Quảng Đà.</li><li>Mã số thuế: 4001202704.</li><li>Địa chỉ: Thôn 2, Xã Bình Đào, Huyện Thăng Bình, Tỉnh Quảng Nam.<br/></li><li></li></ul></div><div class="col-sm-4 col-md-3 item"><h3 class="text-primary">Liên hệ</h3><ul class="list-unstyled"><li>Leader: Trần Ngọc Huy</li><li>Điện thoại/Zalo: 0332813077</li><li>Địa chỉ: 54 Nguyễn Lương Bằng, Liên Chiểu, Đà Nẵng.</li><li></li></ul><img class="w-100" src="/assets/img/zalo.jpg?h=614debe3b6ec66917ebd818aa1c50b6e" loading="lazy" alt="Zalo"/></div></div></div><img src="/assets/img/wave(2).svg?h=5ad7ab1ad1557422fec002e92b1ae54b" alt="Nền"/></footer><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"markdownPost":{"name":null,"url":null,"content":"---\nid: concurrent-mode-reference\ntitle: Concurrent Mode API Reference (Experimental)\npermalink: docs/concurrent-mode-reference.html\nprev: concurrent-mode-adoption.html\n---\n\n\u003cstyle\u003e\n.scary \u003e blockquote {\n  background-color: rgba(237, 51, 21, 0.2);\n  border-left-color: #ed3315;\n}\n\u003c/style\u003e\n\n\u003cdiv class=\"scary\"\u003e\n\n\u003eCaution:\n\u003e\n\u003eThis page describes **experimental features that are [not yet available](/docs/concurrent-mode-adoption.html) in a stable release**. Don't rely on experimental builds of React in production apps. These features may change significantly and without a warning before they become a part of React.\n\u003e\n\u003eThis documentation is aimed at early adopters and people who are curious. **If you're new to React, don't worry about these features** -- you don't need to learn them right now.\n\n\u003c/div\u003e\n\nThis page is an API reference for the React [Concurrent Mode](/docs/concurrent-mode-intro.html). If you're looking for a guided introduction instead, check out [Concurrent UI Patterns](/docs/concurrent-mode-patterns.html).\n\n**Note: This is a Community Preview and not the final stable version. There will likely be future changes to these APIs. Use at your own risk!**\n\n- [Enabling Concurrent Mode](#concurrent-mode)\n    - [`createRoot`](#createroot)\n    - [`createBlockingRoot`](#createblockingroot)\n- [Suspense](#suspense)\n    - [`Suspense`](#suspensecomponent)\n    - [`SuspenseList`](#suspenselist)\n    - [`useTransition`](#usetransition)\n    - [`useDeferredValue`](#usedeferredvalue)\n\n## Enabling Concurrent Mode {#concurrent-mode}\n\n### `createRoot` {#createroot}\n\n```js\nReactDOM.createRoot(rootNode).render(\u003cApp /\u003e);\n```\n\nReplaces `ReactDOM.render(\u003cApp /\u003e, rootNode)` and enables Concurrent Mode.\n\nFor more information on Concurrent Mode, check out the [Concurrent Mode documentation.](/docs/concurrent-mode-intro.html)\n\n### `createBlockingRoot` {#createblockingroot}\n\n```js\nReactDOM.createBlockingRoot(rootNode).render(\u003cApp /\u003e)\n```\n\nReplaces `ReactDOM.render(\u003cApp /\u003e, rootNode)` and enables [Blocking Mode](/docs/concurrent-mode-adoption.html#migration-step-blocking-mode).\n\nOpting into Concurrent Mode introduces semantic changes to how React works. This means that you can't use Concurrent Mode in just a few components. Because of this, some apps may not be able to migrate directly to Concurrent Mode. \n\nBlocking Mode only contains a small subset of Concurrent Mode features and is intended as an intermediary migration step for apps that are unable to migrate directly.\n\n## Suspense API {#suspense}\n\n### `Suspense` {#suspensecomponent}\n\n```js\n\u003cSuspense fallback={\u003ch1\u003eLoading...\u003c/h1\u003e}\u003e\n  \u003cProfilePhoto /\u003e\n  \u003cProfileDetails /\u003e\n\u003c/Suspense\u003e\n```\n\n`Suspense` lets your components \"wait\" for something before they can render, showing a fallback while waiting.\n\nIn this example, `ProfileDetails` is waiting for an asynchronous API call to fetch some data. While we wait for `ProfileDetails` and `ProfilePhoto`, we will show the `Loading...` fallback instead. It is important to note that until all children inside `\u003cSuspense\u003e` has loaded, we will continue to show the fallback.\n\n`Suspense` takes two props:\n* **fallback** takes a loading indicator. The fallback is shown until all of the children of the `Suspense` component have finished rendering.\n* **unstable_avoidThisFallback** takes a boolean. It tells React whether to \"skip\" revealing this boundary during the initial load. This API will likely be removed in a future release.\n\n### `\u003cSuspenseList\u003e` {#suspenselist}\n\n```js\n\u003cSuspenseList revealOrder=\"forwards\"\u003e\n  \u003cSuspense fallback={'Loading...'}\u003e\n    \u003cProfilePicture id={1} /\u003e\n  \u003c/Suspense\u003e\n  \u003cSuspense fallback={'Loading...'}\u003e\n    \u003cProfilePicture id={2} /\u003e\n  \u003c/Suspense\u003e\n  \u003cSuspense fallback={'Loading...'}\u003e\n    \u003cProfilePicture id={3} /\u003e\n  \u003c/Suspense\u003e\n  ...\n\u003c/SuspenseList\u003e\n```\n\n`SuspenseList` helps coordinate many components that can suspend by orchestrating the order in which these components are revealed to the user.\n\nWhen multiple components need to fetch data, this data may arrive in an unpredictable order. However, if you wrap these items in a `SuspenseList`, React will not show an item in the list until previous items have been displayed (this behavior is adjustable).\n\n`SuspenseList` takes two props:\n* **revealOrder (forwards, backwards, together)** defines the order in which the `SuspenseList` children should be revealed.\n  * `together` reveals *all* of them when they're ready instead of one by one.\n* **tail (collapsed, hidden)** dictates how unloaded items in a `SuspenseList` is shown. \n    * By default, `SuspenseList` will show all fallbacks in the list.\n    * `collapsed` shows only the next fallback in the list.\n    * `hidden` doesn't show any unloaded items.\n\nNote that `SuspenseList` only operates on the closest `Suspense` and `SuspenseList` components below it. It does not search for boundaries deeper than one level. However, it is possible to nest multiple `SuspenseList` components in each other to build grids.\n\n### `useTransition` {#usetransition}\n\n```js\nconst SUSPENSE_CONFIG = { timeoutMs: 2000 };\n\nconst [startTransition, isPending] = useTransition(SUSPENSE_CONFIG);\n```\n\n`useTransition` allows components to avoid undesirable loading states by waiting for content to load before **transitioning to the next screen**. It also allows components to defer slower, data fetching updates until subsequent renders so that more crucial updates can be rendered immediately.\n\nThe `useTransition` hook returns two values in an array.\n* `startTransition` is a function that takes a callback. We can use it to tell React which state we want to defer.\n* `isPending` is a boolean. It's React's way of informing us whether we're waiting for the transition to finish.\n\n**If some state update causes a component to suspend, that state update should be wrapped in a transition.**\n\n```js\nconst SUSPENSE_CONFIG = { timeoutMs: 2000 };\n\nfunction App() {\n  const [resource, setResource] = useState(initialResource);\n  const [startTransition, isPending] = useTransition(SUSPENSE_CONFIG);\n  return (\n    \u003c\u003e\n      \u003cbutton\n        disabled={isPending}\n        onClick={() =\u003e {\n          startTransition(() =\u003e {\n            const nextUserId = getNextId(resource.userId);\n            setResource(fetchProfileData(nextUserId));\n          });\n        }}\n      \u003e\n        Next\n      \u003c/button\u003e\n      {isPending ? \" Loading...\" : null}\n      \u003cSuspense fallback={\u003cSpinner /\u003e}\u003e\n        \u003cProfilePage resource={resource} /\u003e\n      \u003c/Suspense\u003e\n    \u003c/\u003e\n  );\n}\n```\n\nIn this code, we've wrapped our data fetching with `startTransition`. This allows us to start fetching the profile data right away, while deferring the render of the next profile page and its associated `Spinner` for 2 seconds (the time shown in `timeoutMs`).\n\nThe `isPending` boolean lets React know that our component is transitioning, so we are able to let the user know this by showing some loading text on the previous profile page.\n\n**For an in-depth look at transitions, you can read [Concurrent UI Patterns](/docs/concurrent-mode-patterns.html#transitions).**\n\n#### useTransition Config {#usetransition-config}\n\n```js\nconst SUSPENSE_CONFIG = { timeoutMs: 2000 };\n```\n\n`useTransition` accepts an **optional Suspense Config** with a `timeoutMs`. This timeout (in milliseconds) tells React how long to wait before showing the next state (the new Profile Page in the above example).\n\n**Note: We recommend that you share Suspense Config between different modules.**\n\n\n### `useDeferredValue` {#usedeferredvalue}\n\n```js\nconst deferredValue = useDeferredValue(value, { timeoutMs: 2000 });\n```\n\nReturns a deferred version of the value that may \"lag behind\" it for at most `timeoutMs`.\n\nThis is commonly used to keep the interface responsive when you have something that renders immediately based on user input and something that needs to wait for a data fetch.\n\nA good example of this is a text input.\n\n```js\nfunction App() {\n  const [text, setText] = useState(\"hello\");\n  const deferredText = useDeferredValue(text, { timeoutMs: 2000 }); \n\n  return (\n    \u003cdiv className=\"App\"\u003e\n      {/* Keep passing the current text to the input */}\n      \u003cinput value={text} onChange={handleChange} /\u003e\n      ...\n      {/* But the list is allowed to \"lag behind\" when necessary */}\n      \u003cMySlowList text={deferredText} /\u003e\n    \u003c/div\u003e\n  );\n }\n```\n\nThis allows us to start showing the new text for the `input` immediately, which allows the webpage to feel responsive. Meanwhile, `MySlowList` \"lags behind\" for up to 2 seconds according to the `timeoutMs` before updating, allowing it to render with the current text in the background.\n\n**For an in-depth look at deferring values, you can read [Concurrent UI Patterns](/docs/concurrent-mode-patterns.html#deferring-a-value).**\n\n#### useDeferredValue Config {#usedeferredvalue-config}\n\n```js\nconst SUSPENSE_CONFIG = { timeoutMs: 2000 };\n```\n\n`useDeferredValue` accepts an **optional Suspense Config** with a `timeoutMs`. This timeout (in milliseconds) tells React how long the deferred value is allowed to lag behind.\n\nReact will always try to use a shorter lag when network and device allows it.\n"}},"__N_SSG":true},"page":"/post/[path]","query":{"path":"_docs_react_basis-concept_concurrent-mode-reference.md"},"buildId":"IU2MQGFEli_aRg5UtGR53","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-4beebf4ac9054f0bf4e6.js"></script><script src="/_next/static/chunks/main-71dd292baef5e0c3d163.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9116e7bff2bfccdffa19.js" async=""></script><script src="/_next/static/chunks/8638dade453fc283329f8b8dee6f6817b55b3944.9475e511f211dbecfbed.js" async=""></script><script src="/_next/static/chunks/pages/_app-de7ed68c6e8649dd556c.js" async=""></script><script src="/_next/static/chunks/pages/post/%5Bpath%5D-98a2b37c69fbc1053078.js" async=""></script><script src="/_next/static/IU2MQGFEli_aRg5UtGR53/_buildManifest.js" async=""></script><script src="/_next/static/IU2MQGFEli_aRg5UtGR53/_ssgManifest.js" async=""></script></body></html>